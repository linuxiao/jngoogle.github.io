{"meta":{"title":"Jngoogle","subtitle":"interesting","description":null,"author":"Jngoogle","url":"https://jngoogle.github.io"},"pages":[{},{},{}],"posts":[{"title":"使用Permissions Dispatcher","date":"2017-09-08T02:48:20.000Z","path":"2017/09/08/使用Permissions-Dispatcher/","text":"这里是原项目地址 Permissions Dispatcher github link 引入库1 添加 maven 支持在你的 Project 这一层级下添加如下代码，提供 maven 支持。 12345678allprojects &#123; repositories &#123; google() jcenter()// TODO 「 how to add PermissionsDispactcher 」 1 - add maven repo dependence maven &#123; url 'http://oss.jfrog.org/artifactory/oss-snapshot-local/' &#125; &#125;&#125; 2 添加项目依赖在你的 Module 这一层级中添加如下代码，提供项目依赖： 1234567891011dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.0.0' // TODO 「 how to add PermissionsDispactcher 」 2 - add dependece in module build.gradle compile(\"com.github.hotchemi:permissionsdispatcher:2.4.0\") &#123;// if you don't use android.app.Fragment you can exclude support for them exclude module: \"support-v13\" &#125; annotationProcessor \"com.github.hotchemi:permissionsdispatcher-processor:2.4.0\"&#125; com.github.hotchemi:permissionsdispatcher:${latest.version} 若想要使用最新版本参考文章开头的原项目。 使用方法 希望你已经熟悉如何使用官方的方式来实现权限管理，若需要学习你可以参考官网教程 Link Permissions Dispatcher 采用注解的方式来简化权限管理 除此之外也建议你去了解一下其他的库 1 为你需要管理权限的 Activity 或 Fragment 添加 @RuntimePermissions@RuntimePermissions 这个注解是必须的，此外还有一个申请权限的注解方法也是必须的 @NeedsPermission。像下面这样添加好你的注解： 1234@RuntimePermissionspublic class MainActivity extends AppCompatActivity &#123;//do something...&#125; 正好我们来看看 Permissions Dispatcher 所有的注解方法 2 使用 @NeedsPermission 来申请你的权限跟官方的方法一样，当你在 Android M （API 23）或者更高的版本中要使用 危险权限的时候，无论如何你先要在 Manifest 中声明你的权限。我们以拨打电话为例子，下面是申请拨打电话权限的代码： 1234567891011@NeedsPermission(Manifest.permission.CALL_PHONE) void callPhoneNumber() &#123; String phoneNumber = phoneNumberEt.getText().toString().trim(); Uri data = Uri.parse(\"tel:\" + phoneNumber); Intent intent = new Intent(Intent.ACTION_CALL, data); try &#123; startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 如果你熟悉注解，应该知道如何申请多个权限。 3 @OnShowRationale 向用户解释权限的宝贵机会当用户使用一个功能但是需要某项权限的时候，若用户没有授权在多次尝试之后如果用户点击了提示对话框中的 Don’t ask again ,之后开发者则失去了打开该权限的机会了，只能用户自行去设置中打开相应的权限。 但是在这之前，你还有一个解释的机会来告诉用户为什么需要授权该权限。这里需要用到 @OnShowRationale 这个注解方法。 12345678910111213141516171819202122@OnShowRationale(Manifest.permission.CALL_PHONE) void showRationaleForCallPhone(final PermissionRequest request) &#123; new AlertDialog .Builder(this) .setTitle(\"Oops\") .setMessage(\"grant call phone permission, if you want call\") .setPositiveButton(\"ok\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; // invoke default dialog for granting permission request.proceed(); &#125; &#125;) .setNegativeButton(\"cancle\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; // invoke @OnPermissionDenied request.cancel(); &#125; &#125;) .show(); &#125; 此段代码块中关键的两个方法： proceed() 和 cancel()。 proceed() ：此方法会调用系统请求权限的对话框cancel()：此方法会回调到 @OnPermissionDenied方法，即用户拒绝授权时候的处理方法。 4 关于Dispatcher 需要注意的问题在你写好了注解方法后跟官方方法一样，在申请权限之前首先需要检查是否 App 已经拥有该权限。官方使用的是 ContextCompat.checkSelfPermission() 这个方法，这里我们要使用 YourActivity + PermissionsDispatcher，我在后面给出的 Demo 例子中使用的是 MainActivity， 所以生成出来的是 MainActivityPermissionsDispatcher。 需要注意的是 Dispatcher 是编译生成的，当你写好上述的一些注解方法之后，此时点击 Android Studio 中的「Make Project」按钮会生成相应的 Dispatcher。 所以在你第一次从 Github 上下载该 Demo 时，你需要按「Make Project」菜单按钮对项目进行编译才能让项目运行。这部分在 Demo 中都有注释说明，包括如何引入库。 5 Demo 项目地址AndroidPermissionDemohave fun !","raw":"---\ntitle: 使用Permissions Dispatcher\ndate: 2017-09-08 10:48:20\ncategories: Android\ntags:\n- permission manage\n- permissions Dispatcher\n---\n\n这里是原项目地址 [Permissions Dispatcher github link](https://github.com/hotchemi/PermissionsDispatcher)\n\n\n\n# 引入库\n\n### 1 添加 maven 支持\n\n在你的 Project 这一层级下添加如下代码，提供 maven 支持。\n\n```java\nallprojects {\n    repositories {\n        google()\n        jcenter()\n//        TODO 「 how to add PermissionsDispactcher 」 1 - add maven repo dependence\n        maven { url 'http://oss.jfrog.org/artifactory/oss-snapshot-local/' }\n    }\n}\n```\n\n\n\n### 2 添加项目依赖\n\n在你的 Module 这一层级中添加如下代码，提供项目依赖：\n\n```java\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:26.0.0'\n    \n//  TODO 「 how to add PermissionsDispactcher 」 2 - add dependece in module build.gradle\n    compile(\"com.github.hotchemi:permissionsdispatcher:2.4.0\") {\n//      if you don't use android.app.Fragment you can exclude support for them\n        exclude module: \"support-v13\"\n    }\n    annotationProcessor \"com.github.hotchemi:permissionsdispatcher-processor:2.4.0\"\n}\n```\n\n `com.github.hotchemi:permissionsdispatcher:${latest.version}` 若想要使用最新版本参考文章开头的原项目。\n\n<br>\n\n\n\n# 使用方法\n\n> - 希望你已经熟悉如何使用官方的方式来实现权限管理，若需要学习你可以参考官网教程 [Link](https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html?hl=zh-cn)\n> - Permissions Dispatcher 采用注解的方式来简化权限管理\n> - 除此之外也建议你去了解一下其他的库\n\n\n\n### 1 为你需要管理权限的 Activity 或 Fragment 添加 `@RuntimePermissions`\n\n`@RuntimePermissions` 这个注解是必须的，此外还有一个申请权限的注解方法也是必须的 `@NeedsPermission`。\n像下面这样添加好你的注解：\n\n```java\n@RuntimePermissions\npublic class MainActivity extends AppCompatActivity {\n//do something...\n}\n```\n\n正好我们来看看 Permissions Dispatcher 所有的注解方法\n\n![permssions](https://s1.imgchr.com/2017/09/08/mhYUs.png)\n\n\n\n### 2 使用 `@NeedsPermission` 来申请你的权限\n\n跟官方的方法一样，当你在 Android M （API 23）或者更高的版本中要使用 `危险权限`的时候，无论如何你先要在 `Manifest` 中声明你的权限。我们以拨打电话为例子，下面是申请拨打电话权限的代码：\n\n```java\n@NeedsPermission(Manifest.permission.CALL_PHONE)\n    void callPhoneNumber() {\n        String phoneNumber = phoneNumberEt.getText().toString().trim();\n        Uri data = Uri.parse(\"tel:\" + phoneNumber);\n        Intent intent = new Intent(Intent.ACTION_CALL, data);\n        try {\n            startActivity(intent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n如果你熟悉注解，应该知道如何申请多个权限。\n\n\n### 3 `@OnShowRationale` 向用户解释权限的宝贵机会\n\n当用户使用一个功能但是需要某项权限的时候，若用户没有授权在多次尝试之后如果用户点击了提示对话框中的 Don't ask again ,之后开发者则失去了打开该权限的机会了，只能用户自行去设置中打开相应的权限。\n\n但是在这之前，你还有一个解释的机会来告诉用户为什么需要授权该权限。这里需要用到 `@OnShowRationale` 这个注解方法。\n\n```java\n@OnShowRationale(Manifest.permission.CALL_PHONE)\n    void showRationaleForCallPhone(final PermissionRequest request) {\n        new AlertDialog\n                .Builder(this)\n                .setTitle(\"Oops\")\n                .setMessage(\"grant call phone permission, if you want call\")\n                .setPositiveButton(\"ok\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        // invoke default dialog for granting permission\n                        request.proceed();\n                    }\n                })\n                .setNegativeButton(\"cancle\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        // invoke @OnPermissionDenied\n                        request.cancel();\n                    }\n                })\n                .show();\n    }\n```\n\n此段代码块中关键的两个方法： `proceed()`  和  `cancel()`。\n\n`proceed()` ：此方法会调用系统请求权限的对话框\n`cancel()`：此方法会回调到 `@OnPermissionDenied`方法，即用户拒绝授权时候的处理方法。\n\n\n### 4 关于Dispatcher 需要注意的问题\n\n在你写好了注解方法后跟官方方法一样，在申请权限之前首先需要检查是否 App 已经拥有该权限。官方使用的是 `ContextCompat.checkSelfPermission()` 这个方法，这里我们要使用  YourActivity + PermissionsDispatcher，我在后面给出的 Demo 例子中使用的是 MainActivity， 所以生成出来的是 MainActivityPermissionsDispatcher。\n\n**需要注意的是 Dispatcher 是编译生成的，当你写好上述的一些注解方法之后，此时点击 Android Studio 中的「Make Project」按钮会生成相应的 Dispatcher。**\n\n**所以在你第一次从 Github 上下载该 Demo 时，你需要按「Make Project」菜单按钮对项目进行编译才能让项目运行。**这部分在 Demo 中都有注释说明，包括如何引入库。\n\n\n### 5 Demo 项目地址\n\n[AndroidPermissionDemo](https://github.com/jngoogle/AndroidPermissionDemo)\n<br>\nhave fun !\n\n ","content":"<p>这里是原项目地址 <a href=\"https://github.com/hotchemi/PermissionsDispatcher\" target=\"_blank\" rel=\"external\">Permissions Dispatcher github link</a></p>\n<h1 id=\"引入库\"><a href=\"#引入库\" class=\"headerlink\" title=\"引入库\"></a>引入库</h1><h3 id=\"1-添加-maven-支持\"><a href=\"#1-添加-maven-支持\" class=\"headerlink\" title=\"1 添加 maven 支持\"></a>1 添加 maven 支持</h3><p>在你的 Project 这一层级下添加如下代码，提供 maven 支持。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">allprojects &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        google()</div><div class=\"line\">        jcenter()</div><div class=\"line\"><span class=\"comment\">//        TODO 「 how to add PermissionsDispactcher 」 1 - add maven repo dependence</span></div><div class=\"line\">        maven &#123; url <span class=\"string\">'http://oss.jfrog.org/artifactory/oss-snapshot-local/'</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-添加项目依赖\"><a href=\"#2-添加项目依赖\" class=\"headerlink\" title=\"2 添加项目依赖\"></a>2 添加项目依赖</h3><p>在你的 Module 这一层级中添加如下代码，提供项目依赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    <span class=\"function\">implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></div><div class=\"line\">    implementation 'com.android.support:appcompat-v7:26.0.0'</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//  TODO 「 how to add PermissionsDispactcher 」 2 - add dependece in module build.gradle</span></div><div class=\"line\">    <span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">\"com.github.hotchemi:permissionsdispatcher:2.4.0\"</span>)</span> &#123;</div><div class=\"line\"><span class=\"comment\">//      if you don't use android.app.Fragment you can exclude support for them</span></div><div class=\"line\">        exclude <span class=\"keyword\">module</span>: <span class=\"string\">\"support-v13\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    annotationProcessor <span class=\"string\">\"com.github.hotchemi:permissionsdispatcher-processor:2.4.0\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <code>com.github.hotchemi:permissionsdispatcher:${latest.version}</code> 若想要使用最新版本参考文章开头的原项目。</p>\n<p><br></p>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><blockquote>\n<ul>\n<li>希望你已经熟悉如何使用官方的方式来实现权限管理，若需要学习你可以参考官网教程 <a href=\"https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html?hl=zh-cn\" target=\"_blank\" rel=\"external\">Link</a></li>\n<li>Permissions Dispatcher 采用注解的方式来简化权限管理</li>\n<li>除此之外也建议你去了解一下其他的库</li>\n</ul>\n</blockquote>\n<h3 id=\"1-为你需要管理权限的-Activity-或-Fragment-添加-RuntimePermissions\"><a href=\"#1-为你需要管理权限的-Activity-或-Fragment-添加-RuntimePermissions\" class=\"headerlink\" title=\"1 为你需要管理权限的 Activity 或 Fragment 添加 @RuntimePermissions\"></a>1 为你需要管理权限的 Activity 或 Fragment 添加 <code>@RuntimePermissions</code></h3><p><code>@RuntimePermissions</code> 这个注解是必须的，此外还有一个申请权限的注解方法也是必须的 <code>@NeedsPermission</code>。<br>像下面这样添加好你的注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RuntimePermissions</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//do something...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正好我们来看看 Permissions Dispatcher 所有的注解方法</p>\n<p><img src=\"https://s1.imgchr.com/2017/09/08/mhYUs.png\" alt=\"permssions\"></p>\n<h3 id=\"2-使用-NeedsPermission-来申请你的权限\"><a href=\"#2-使用-NeedsPermission-来申请你的权限\" class=\"headerlink\" title=\"2 使用 @NeedsPermission 来申请你的权限\"></a>2 使用 <code>@NeedsPermission</code> 来申请你的权限</h3><p>跟官方的方法一样，当你在 Android M （API 23）或者更高的版本中要使用 <code>危险权限</code>的时候，无论如何你先要在 <code>Manifest</code> 中声明你的权限。我们以拨打电话为例子，下面是申请拨打电话权限的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NeedsPermission</span>(Manifest.permission.CALL_PHONE)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callPhoneNumber</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        String phoneNumber = phoneNumberEt.getText().toString().trim();</div><div class=\"line\">        Uri data = Uri.parse(<span class=\"string\">\"tel:\"</span> + phoneNumber);</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_CALL, data);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            startActivity(intent);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>如果你熟悉注解，应该知道如何申请多个权限。</p>\n<h3 id=\"3-OnShowRationale-向用户解释权限的宝贵机会\"><a href=\"#3-OnShowRationale-向用户解释权限的宝贵机会\" class=\"headerlink\" title=\"3 @OnShowRationale 向用户解释权限的宝贵机会\"></a>3 <code>@OnShowRationale</code> 向用户解释权限的宝贵机会</h3><p>当用户使用一个功能但是需要某项权限的时候，若用户没有授权在多次尝试之后如果用户点击了提示对话框中的 Don’t ask again ,之后开发者则失去了打开该权限的机会了，只能用户自行去设置中打开相应的权限。</p>\n<p>但是在这之前，你还有一个解释的机会来告诉用户为什么需要授权该权限。这里需要用到 <code>@OnShowRationale</code> 这个注解方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnShowRationale</span>(Manifest.permission.CALL_PHONE)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showRationaleForCallPhone</span><span class=\"params\">(<span class=\"keyword\">final</span> PermissionRequest request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> AlertDialog</div><div class=\"line\">                .Builder(<span class=\"keyword\">this</span>)</div><div class=\"line\">                .setTitle(<span class=\"string\">\"Oops\"</span>)</div><div class=\"line\">                .setMessage(<span class=\"string\">\"grant call phone permission, if you want call\"</span>)</div><div class=\"line\">                .setPositiveButton(<span class=\"string\">\"ok\"</span>, <span class=\"keyword\">new</span> DialogInterface.OnClickListener() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(DialogInterface dialogInterface, <span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// invoke default dialog for granting permission</span></div><div class=\"line\">                        request.proceed();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;)</div><div class=\"line\">                .setNegativeButton(<span class=\"string\">\"cancle\"</span>, <span class=\"keyword\">new</span> DialogInterface.OnClickListener() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(DialogInterface dialogInterface, <span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// invoke @OnPermissionDenied</span></div><div class=\"line\">                        request.cancel();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;)</div><div class=\"line\">                .show();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>此段代码块中关键的两个方法： <code>proceed()</code>  和  <code>cancel()</code>。</p>\n<p><code>proceed()</code> ：此方法会调用系统请求权限的对话框<br><code>cancel()</code>：此方法会回调到 <code>@OnPermissionDenied</code>方法，即用户拒绝授权时候的处理方法。</p>\n<h3 id=\"4-关于Dispatcher-需要注意的问题\"><a href=\"#4-关于Dispatcher-需要注意的问题\" class=\"headerlink\" title=\"4 关于Dispatcher 需要注意的问题\"></a>4 关于Dispatcher 需要注意的问题</h3><p>在你写好了注解方法后跟官方方法一样，在申请权限之前首先需要检查是否 App 已经拥有该权限。官方使用的是 <code>ContextCompat.checkSelfPermission()</code> 这个方法，这里我们要使用  YourActivity + PermissionsDispatcher，我在后面给出的 Demo 例子中使用的是 MainActivity， 所以生成出来的是 MainActivityPermissionsDispatcher。</p>\n<p><strong>需要注意的是 Dispatcher 是编译生成的，当你写好上述的一些注解方法之后，此时点击 Android Studio 中的「Make Project」按钮会生成相应的 Dispatcher。</strong></p>\n<p><strong>所以在你第一次从 Github 上下载该 Demo 时，你需要按「Make Project」菜单按钮对项目进行编译才能让项目运行。</strong>这部分在 Demo 中都有注释说明，包括如何引入库。</p>\n<h3 id=\"5-Demo-项目地址\"><a href=\"#5-Demo-项目地址\" class=\"headerlink\" title=\"5 Demo 项目地址\"></a>5 Demo 项目地址</h3><p><a href=\"https://github.com/jngoogle/AndroidPermissionDemo\" target=\"_blank\" rel=\"external\">AndroidPermissionDemo</a><br><br><br>have fun !</p>\n","slug":"使用Permissions-Dispatcher","updated":"2017-09-08T03:13:43.495Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2017/09/08/使用Permissions-Dispatcher/","excerpt":"","categories":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/categories/Android/"}],"tags":[{"name":"permission manage","slug":"permission-manage","permalink":"https://jngoogle.github.io/tags/permission-manage/"},{"name":"permissions Dispatcher","slug":"permissions-Dispatcher","permalink":"https://jngoogle.github.io/tags/permissions-Dispatcher/"}]},{"title":"通用的RecyclerViewAdapter开发","date":"2017-07-10T03:31:11.000Z","path":"2017/07/10/开发RecyclerViewAdapter简化日常开发/","text":"前言日常开发中经常会使用到的重复性的工作应当让它简单化、流程化、自动化。 思路想要开发实现通用的 RecyclerViewAdapter 我们先要了解官方的 Adapter 是如何使用的，然后在此基础上进行抽象。下面我们就先来看一下官方的 Adapter 的使用范例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class NormalRecyclerViewAdapter extends RecyclerView.Adapter&lt;NormalRecyclerViewAdapter.NormalTextViewHolder&gt; &#123;private final LayoutInflater mLayoutInflater;private final Context mContext;private String[] mTitles; public NormalRecyclerViewAdapter(Context context) &#123; mTitles = context.getResources().getStringArray(R.array.titles); mContext = context; mLayoutInflater = LayoutInflater.from(context);&#125; @Overridepublic NormalTextViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new NormalTextViewHolder(mLayoutInflater.inflate(R.layout.item_text, parent, false));&#125; @Overridepublic void onBindViewHolder(NormalTextViewHolder holder, int position) &#123; holder.mTextView.setText(mTitles[position]);&#125; @Overridepublic int getItemCount() &#123; return mTitles == null ? 0 : mTitles.length;&#125; public static class NormalTextViewHolder extends RecyclerView.ViewHolder &#123; @InjectView(R.id.text_view) TextView mTextView; NormalTextViewHolder(View view) &#123; super(view); ButterKnife.inject(this, view); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d(\"NormalTextViewHolder\", \"onClick--&gt; position = \" + getPosition()); &#125; &#125;); &#125; &#125;&#125; 我们来归纳一下 adapter 使用的几个重要的点。 1.使用 RecyclerViewAdapter 需要重写三个方法onCreateViewHolder() onBindViewHolder() getItemCount() 。 2.需要自己实现 ViewHolder ，用来绑定 itemView 中的视图与数据. 实现实现三个重写方法step1 onCreateViewHolder() 方法首先我们来看第一个重写的方法 onCreateViewHolder()该方法作用是创建 ViewHolder 使得 itemView 与对应的数据进行绑定，那我们就需要先来创建自己的 ViewHolder。 我们先理一下 viewholder 中代码的逻辑。首先我们在 viewholder 中创建了 itemView 中所需要的各个 view 并初始化它们。接着我们给这个 view 设置了点击事件。我们开发一个通用的 viewholder 来完成上面的工作。需要先创建 itemView 中的各个 view 然后初始化它们。在事先不知道view类型的情况下，要在运行时获得view 的类型并初始化，我们使用泛型的方式来实现，代码如下： 1234public &lt;T extends View&gt; T getView(int resId) &#123; View childView = itemView.findViewById(resId); return (T) childView; &#125; 其中的 itemview 是在 viewholder 的构造方法中需要传入的列表项布局的参数。这样通过 resId ，我们可以得到这个 itemView 中任何一个子 view 了。在这里我们同时也把这个子 view 初始化完毕了。 接下来我们给里面的子 view 都添加上点击事件。模仿官方的用法，我们同样在 viewholder 中实现 点击事件的监听（以下是完整的 viewholder 代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener &#123; private Context context = null; public MyViewHolder(Context context, View itemView) &#123; super(itemView); this.context = context; &#125; public &lt;T extends View&gt; T getView(int resId) &#123; View childView = itemView.findViewById(resId); return (T) childView; &#125; public MyViewHolder setText(int resId, String text) &#123; TextView textView = getView(resId); textView.setText(text); return this; &#125; public MyViewHolder setTextColor(int resId, int colorId) &#123; TextView textView = getView(resId); textView.setTextColor(colorId); return this; &#125; public MyViewHolder setImageResource(int viewId, int drawableId) &#123; ImageView imageView = getView(viewId); imageView.setImageResource(drawableId); return this; &#125; public MyViewHolder setImageBitmap(int viewId, Bitmap bm) &#123; ImageView view = getView(viewId); view.setImageBitmap(bm); return this; &#125; @Override public void onClick(View v) &#123; if (iOnItemClickListener != null) &#123; // 此处需要注意如何获取 itemView 的位置 iOnItemClickListener.onClick(itemView, this.getAdapterPosition()); &#125; &#125; &#125; public interface IOnItemClickListener &#123; void onClick(View view, int position); &#125; 这里我们在 onClick() 这个点击事件的方法中不要实现具体的点击逻辑，抽象成一个接口留给实现类去实现。这里我们在 onClick() 中是调用了 iOnItemClickListener 接口的 onClick() 方法。之后在 adapter 中提供调用该接口的方法供实现类去使用。 这里我们可以发现在上面自定义的 viewholder 中，我们添加了一些常用的方法例如：setText() 等。可根据自身项目的实际情况逐渐的去完善这些常用的方法，最终形成自己的独有的 viewholder 。 step2 onBindViewHolder() 方法这个方法在官方的 adapter 中是通过 viewholder 来把 itemView 中的子 View 与其数据绑定在一起。这里我们开发通用的 adapter 不知道运行时子 View 的类型，需要使用抽象的方法把具体的实现交给子类去完成。代码如下： 12345678@Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (dataList == null) &#123; return; &#125; else &#123; bindDataList(resId, dataList);// 由子类 adapter 决定具体如何绑定 &#125; &#125; 这里的 bindDataList() 是一个抽象方法，留给子类具体去实现具体的子 View 绑定具体的数据。 step3 onItemCount() 方法获得数据的数量，代码如下： 1234@Override public int getItemCount() &#123; return dataList == null ? 0 : dataList.size(); &#125; 以上就完成了我们通用 RecyclerviewAdapter 的开发了。下面是所有的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public abstract class CommonRecyclerAdapter&lt;Data&gt; extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private Context context; private IOnItemClickListener iOnItemClickListener = null; private int resId;// item 布局id private List&lt;Data&gt; dataList; public CommonRecyclerAdapter(Context context, int resId) &#123; this(context, resId, null); &#125; public CommonRecyclerAdapter(Context context, int resId, List&lt;Data&gt; dataList) &#123; this.context = context; this.resId = resId; this.dataList = dataList; &#125; public void setOnItemClickListener(IOnItemClickListener iOnItemClickListener) &#123; this.iOnItemClickListener = iOnItemClickListener; &#125; public void setDataList(List&lt;Data&gt; dataList) &#123; this.dataList = dataList; &#125; public void clearDataList() &#123; if (dataList != null) &#123; dataList.clear(); notifyDataSetChanged(); &#125; &#125; public List&lt;Data&gt; getDataList() &#123; if (dataList != null) &#123; return dataList; &#125; return null; &#125; public void addDataList() &#123; if (this.dataList == null) &#123; this.dataList = new ArrayList&lt;&gt;(); &#125; this.dataList.addAll(dataList); notifyDataSetChanged(); &#125; public abstract void bindDataList(int resId, List&lt;Data&gt; dataList); @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new MyViewHolder(context, LayoutInflater.from(context).inflate(resId, parent, false)); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (dataList == null) &#123; return; &#125; else &#123; bindDataList(resId, dataList);// 由子类 adapter 决定具体如何绑定 &#125; &#125; @Override public int getItemCount() &#123; return dataList == null ? 0 : dataList.size(); &#125; public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener &#123; private Context context = null; public MyViewHolder(Context context, View itemView) &#123; super(itemView); this.context = context; &#125; public &lt;T extends View&gt; T getView(int resId) &#123; View childView = itemView.findViewById(resId); return (T) childView; &#125; //================= 以下为常用方法可自行增加 ======================= public MyViewHolder setText(int resId, String text) &#123; TextView textView = getView(resId); textView.setText(text); return this; &#125; public MyViewHolder setTextColor(int resId, int colorId) &#123; TextView textView = getView(resId); textView.setTextColor(colorId); return this; &#125; public MyViewHolder setImageResource(int viewId, int drawableId) &#123; ImageView imageView = getView(viewId); imageView.setImageResource(drawableId); return this; &#125; public MyViewHolder setImageBitmap(int viewId, Bitmap bm) &#123; ImageView view = getView(viewId); view.setImageBitmap(bm); return this; &#125; //================================================================= @Override public void onClick(View v) &#123; if (iOnItemClickListener != null) &#123; // 此处需要注意如何获取 itemView 的位置 iOnItemClickListener.onClick(itemView, this.getAdapterPosition()); &#125; &#125; &#125; public interface IOnItemClickListener &#123; void onClick(View view, int position); &#125;&#125; 使用使用的时候自定义一个 recyclerviewAdapter 继承这个通用的 adapter 实现父类的抽象方法（数据绑定）即可。 12345678910111213private class MyRecyclerAdapter extends CommonRecyclerAdapter&lt;Subject&gt; &#123; public MyRecyclerAdapter(Context context, int resId) &#123; super(context, resId); &#125; @Override public void bindDataList(MyViewHolder holder, int position, Subject itemData) &#123; holder.setText(R.id.tv_title_movie, itemData.getTitle()); holder.setImageResource(context, R.id.iv_cover_movie, itemData.getImages().getMedium(), R.mipmap.ic_launcher); &#125; &#125; 剩下的就是跟官方使用方式一样。 123movieLv = (RecyclerView) findViewById(R.id.lv_pic_movie);movieLv.setLayoutManager(new LinearLayoutManager(context));myRecyclerAdapter = new MyRecyclerAdapter(context, R.layout.item_list_layout); 12myRecyclerAdapter.setDataList(subjects);movieLv.setAdapter(myRecyclerAdapter);","raw":"---\ntitle: 通用的RecyclerViewAdapter开发\ndate: 2017-07-10 11:31:11\ncategories: Android\ntags:\n- Android\n- View\n---\n\n# 前言\n\n日常开发中经常会使用到的重复性的工作应当让它简单化、流程化、自动化。\n\n\n\n# 思路\n\n想要开发实现通用的 RecyclerViewAdapter 我们先要了解官方的 Adapter 是如何使用的，然后在此基础上进行抽象。下面我们就先来看一下官方的 Adapter 的使用范例。\n\n```java\npublic class NormalRecyclerViewAdapter extends RecyclerView.Adapter<NormalRecyclerViewAdapter.NormalTextViewHolder> {\n\nprivate final LayoutInflater mLayoutInflater;\nprivate final Context mContext;\nprivate String[] mTitles;\n\n  \npublic NormalRecyclerViewAdapter(Context context) {\n    mTitles = context.getResources().getStringArray(R.array.titles);\n    mContext = context;\n    mLayoutInflater = LayoutInflater.from(context);\n}\n  \n@Override\npublic NormalTextViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    return new NormalTextViewHolder(mLayoutInflater.inflate(R.layout.item_text, parent, false));\n}\n \n@Override\npublic void onBindViewHolder(NormalTextViewHolder holder, int position) {\n    holder.mTextView.setText(mTitles[position]);\n}\n\n  \n@Override\npublic int getItemCount() {\n    return mTitles == null ? 0 : mTitles.length;\n}\n  \npublic static class NormalTextViewHolder extends RecyclerView.ViewHolder {\n    @InjectView(R.id.text_view)\n    TextView mTextView;\n\n    NormalTextViewHolder(View view) {\n        super(view);\n        ButterKnife.inject(this, view);\n        view.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.d(\"NormalTextViewHolder\", \"onClick--> position = \" + getPosition());\n            }\n        });\n    }\n  }\n}\n```\n> 我们来归纳一下 adapter 使用的几个重要的点。\n>\n> 1.使用 RecyclerViewAdapter 需要重写三个方法`onCreateViewHolder()\t `     `onBindViewHolder()`\t`getItemCount()` 。\n>\n> 2.需要自己实现 ViewHolder ，用来绑定 itemView  中的视图与数据.\n\n\n\n# 实现 \n\n## 实现三个重写方法\n\n### step1  onCreateViewHolder()  方法\n\n首先我们来看第一个重写的方法 onCreateViewHolder()该方法作用是创建 ViewHolder 使得 itemView 与对应的数据进行绑定，那我们就需要先来创建自己的 ViewHolder。\n\n我们先理一下 viewholder 中代码的逻辑。首先我们在 viewholder 中创建了 itemView 中所需要的各个 view 并初始化它们。接着我们给这个 view 设置了点击事件。我们开发一个通用的 viewholder 来完成上面的工作。需要先创建 itemView 中的各个 view 然后初始化它们。在事先不知道view类型的情况下，要在运行时获得view 的类型并初始化，我们使用泛型的方式来实现，代码如下：\n\n```java\npublic <T extends View> T getView(int resId) {\n            View childView = itemView.findViewById(resId);\n            return (T) childView;\n        }\n```\n\n其中的 itemview 是在 viewholder 的构造方法中需要传入的列表项布局的参数。这样通过 resId  ，我们可以得到这个 itemView  中任何一个子 view 了。在这里我们同时也把这个子 view 初始化完毕了。\n\n接下来我们给里面的子 view 都添加上点击事件。模仿官方的用法，我们同样在 viewholder 中实现 点击事件的监听（以下是完整的 viewholder  代码）。\n\n```java\n public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {\n\n        private Context context = null;\n\n        public MyViewHolder(Context context, View itemView) {\n            super(itemView);\n            this.context = context;\n        }\n\n        public <T extends View> T getView(int resId) {\n            View childView = itemView.findViewById(resId);\n            return (T) childView;\n        }\n   \n        public MyViewHolder setText(int resId, String text) {\n            TextView textView = getView(resId);\n            textView.setText(text);\n            return this;\n        }\n\n        public MyViewHolder setTextColor(int resId, int colorId) {\n            TextView textView = getView(resId);\n            textView.setTextColor(colorId);\n            return this;\n        }\n\n        public MyViewHolder setImageResource(int viewId, int drawableId) {\n            ImageView imageView = getView(viewId);\n            imageView.setImageResource(drawableId);\n            return this;\n        }\n\n        public MyViewHolder setImageBitmap(int viewId, Bitmap bm) {\n            ImageView view = getView(viewId);\n            view.setImageBitmap(bm);\n            return this;\n        }\n\n        @Override\n        public void onClick(View v) {\n            if (iOnItemClickListener != null) {\n                // 此处需要注意如何获取 itemView 的位置\n                iOnItemClickListener.onClick(itemView, this.getAdapterPosition());\n            }\n        }\n\n    }\n\n    public interface IOnItemClickListener {\n        void onClick(View view, int position);\n    }\n```\n\n这里我们在 onClick()  这个点击事件的方法中不要实现具体的点击逻辑，抽象成一个接口留给实现类去实现。这里我们在 onClick()  中是调用了 iOnItemClickListener 接口的 onClick()  方法。之后在 adapter  中提供调用该接口的方法供实现类去使用。\n\n> 这里我们可以发现在上面自定义的 viewholder 中，我们添加了一些常用的方法例如：setText()  等。可根据自身项目的实际情况逐渐的去完善这些常用的方法，最终形成自己的独有的 viewholder 。\n\n\n\n### step2  onBindViewHolder()  方法\n\n这个方法在官方的 adapter  中是通过 viewholder  来把 itemView  中的子 View  与其数据绑定在一起。这里我们开发通用的 adapter  不知道运行时子 View 的类型，需要使用抽象的方法把具体的实现交给子类去完成。代码如下：\n\n```java\n @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        if (dataList == null) {\n            return;\n        } else {\n            bindDataList(resId, dataList);// 由子类 adapter 决定具体如何绑定\n        }\n    }\n```\n\n> 这里的 `bindDataList()`  是一个抽象方法，留给子类具体去实现具体的子 View  绑定具体的数据。\n\n\n\n### step3   onItemCount()  方法\n\n获得数据的数量，代码如下：\n\n```java\n@Override\n    public int getItemCount() {\n        return dataList == null ? 0 : dataList.size();\n    }\n```\n\n\n\n以上就完成了我们通用 RecyclerviewAdapter 的开发了。下面是所有的代码：\n\n```java\npublic abstract class CommonRecyclerAdapter<Data> extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n\n    private Context context;\n    private IOnItemClickListener iOnItemClickListener = null;\n    private int resId;// item 布局id\n    private List<Data> dataList;\n\n    public CommonRecyclerAdapter(Context context, int resId) {\n        this(context, resId, null);\n    }\n\n    public CommonRecyclerAdapter(Context context, int resId, List<Data> dataList) {\n        this.context = context;\n        this.resId = resId;\n        this.dataList = dataList;\n    }\n\n    public void setOnItemClickListener(IOnItemClickListener iOnItemClickListener) {\n        this.iOnItemClickListener = iOnItemClickListener;\n    }\n\n    public void setDataList(List<Data> dataList) {\n        this.dataList = dataList;\n    }\n\n    public void clearDataList() {\n        if (dataList != null) {\n            dataList.clear();\n            notifyDataSetChanged();\n        }\n\n    }\n\n    public List<Data> getDataList() {\n        if (dataList != null) {\n            return dataList;\n        }\n\n        return null;\n    }\n\n    public void addDataList() {\n        if (this.dataList == null) {\n            this.dataList = new ArrayList<>();\n        }\n        this.dataList.addAll(dataList);\n        notifyDataSetChanged();\n    }\n\n    public abstract void bindDataList(int resId, List<Data> dataList);\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        return new MyViewHolder(context, LayoutInflater.from(context).inflate(resId, parent, false));\n    }\n\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        if (dataList == null) {\n            return;\n        } else {\n            bindDataList(resId, dataList);// 由子类 adapter 决定具体如何绑定\n        }\n    }\n\n    @Override\n    public int getItemCount() {\n        return dataList == null ? 0 : dataList.size();\n    }\n\n    public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {\n\n        private Context context = null;\n\n        public MyViewHolder(Context context, View itemView) {\n            super(itemView);\n            this.context = context;\n        }\n\n        public <T extends View> T getView(int resId) {\n            View childView = itemView.findViewById(resId);\n            return (T) childView;\n        }\n\n        //================= 以下为常用方法可自行增加 =======================\n        public MyViewHolder setText(int resId, String text) {\n            TextView textView = getView(resId);\n            textView.setText(text);\n            return this;\n        }\n\n        public MyViewHolder setTextColor(int resId, int colorId) {\n            TextView textView = getView(resId);\n            textView.setTextColor(colorId);\n            return this;\n        }\n\n        public MyViewHolder setImageResource(int viewId, int drawableId) {\n            ImageView imageView = getView(viewId);\n            imageView.setImageResource(drawableId);\n            return this;\n        }\n\n        public MyViewHolder setImageBitmap(int viewId, Bitmap bm) {\n            ImageView view = getView(viewId);\n            view.setImageBitmap(bm);\n            return this;\n        }\n\n        //=================================================================\n\n        @Override\n        public void onClick(View v) {\n            if (iOnItemClickListener != null) {\n                // 此处需要注意如何获取 itemView 的位置\n                iOnItemClickListener.onClick(itemView, this.getAdapterPosition());\n            }\n        }\n\n    }\n\n    public interface IOnItemClickListener {\n        void onClick(View view, int position);\n    }\n}\n```\n\n\n\n# 使用\n\n使用的时候自定义一个 recyclerviewAdapter 继承这个通用的 adapter  实现父类的抽象方法（数据绑定）即可。\n\n```java\nprivate class MyRecyclerAdapter extends CommonRecyclerAdapter<Subject> {\n\n        public MyRecyclerAdapter(Context context, int resId) {\n            super(context, resId);\n        }\n\n        @Override\n        public void bindDataList(MyViewHolder holder, int position, Subject itemData) {\n            holder.setText(R.id.tv_title_movie, itemData.getTitle());\n            holder.setImageResource(context, R.id.iv_cover_movie, itemData.getImages().getMedium(), R.mipmap.ic_launcher);\n        }\n\n    }\n```\n\n剩下的就是跟官方使用方式一样。\n\n``` java\nmovieLv = (RecyclerView) findViewById(R.id.lv_pic_movie);\nmovieLv.setLayoutManager(new LinearLayoutManager(context));\nmyRecyclerAdapter = new MyRecyclerAdapter(context, R.layout.item_list_layout);\n```\n\n```\nmyRecyclerAdapter.setDataList(subjects);\nmovieLv.setAdapter(myRecyclerAdapter);\n```\n\n","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>日常开发中经常会使用到的重复性的工作应当让它简单化、流程化、自动化。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>想要开发实现通用的 RecyclerViewAdapter 我们先要了解官方的 Adapter 是如何使用的，然后在此基础上进行抽象。下面我们就先来看一下官方的 Adapter 的使用范例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalRecyclerViewAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">NormalRecyclerViewAdapter</span>.<span class=\"title\">NormalTextViewHolder</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LayoutInflater mLayoutInflater;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Context mContext;</div><div class=\"line\"><span class=\"keyword\">private</span> String[] mTitles;</div><div class=\"line\"></div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NormalRecyclerViewAdapter</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    mTitles = context.getResources().getStringArray(R.array.titles);</div><div class=\"line\">    mContext = context;</div><div class=\"line\">    mLayoutInflater = LayoutInflater.from(context);</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NormalTextViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NormalTextViewHolder(mLayoutInflater.inflate(R.layout.item_text, parent, <span class=\"keyword\">false</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(NormalTextViewHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">    holder.mTextView.setText(mTitles[position]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTitles == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : mTitles.length;</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalTextViewHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@InjectView</span>(R.id.text_view)</div><div class=\"line\">    TextView mTextView;</div><div class=\"line\"></div><div class=\"line\">    NormalTextViewHolder(View view) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(view);</div><div class=\"line\">        ButterKnife.inject(<span class=\"keyword\">this</span>, view);</div><div class=\"line\">        view.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">                Log.d(<span class=\"string\">\"NormalTextViewHolder\"</span>, <span class=\"string\">\"onClick--&gt; position = \"</span> + getPosition());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>我们来归纳一下 adapter 使用的几个重要的点。</p>\n<p>1.使用 RecyclerViewAdapter 需要重写三个方法<code>onCreateViewHolder()</code>     <code>onBindViewHolder()</code>    <code>getItemCount()</code> 。</p>\n<p>2.需要自己实现 ViewHolder ，用来绑定 itemView  中的视图与数据.</p>\n</blockquote>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"实现三个重写方法\"><a href=\"#实现三个重写方法\" class=\"headerlink\" title=\"实现三个重写方法\"></a>实现三个重写方法</h2><h3 id=\"step1-onCreateViewHolder-方法\"><a href=\"#step1-onCreateViewHolder-方法\" class=\"headerlink\" title=\"step1  onCreateViewHolder()  方法\"></a>step1  onCreateViewHolder()  方法</h3><p>首先我们来看第一个重写的方法 onCreateViewHolder()该方法作用是创建 ViewHolder 使得 itemView 与对应的数据进行绑定，那我们就需要先来创建自己的 ViewHolder。</p>\n<p>我们先理一下 viewholder 中代码的逻辑。首先我们在 viewholder 中创建了 itemView 中所需要的各个 view 并初始化它们。接着我们给这个 view 设置了点击事件。我们开发一个通用的 viewholder 来完成上面的工作。需要先创建 itemView 中的各个 view 然后初始化它们。在事先不知道view类型的情况下，要在运行时获得view 的类型并初始化，我们使用泛型的方式来实现，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T extends View&gt; <span class=\"function\">T <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</div><div class=\"line\">            View childView = itemView.findViewById(resId);</div><div class=\"line\">            <span class=\"keyword\">return</span> (T) childView;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>其中的 itemview 是在 viewholder 的构造方法中需要传入的列表项布局的参数。这样通过 resId  ，我们可以得到这个 itemView  中任何一个子 view 了。在这里我们同时也把这个子 view 初始化完毕了。</p>\n<p>接下来我们给里面的子 view 都添加上点击事件。模仿官方的用法，我们同样在 viewholder 中实现 点击事件的监听（以下是完整的 viewholder  代码）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyViewHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnClickListener</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">private</span> Context context = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyViewHolder</span><span class=\"params\">(Context context, View itemView)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">super</span>(itemView);</div><div class=\"line\">           <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">public</span> &lt;T extends View&gt; <span class=\"function\">T <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</div><div class=\"line\">           View childView = itemView.findViewById(resId);</div><div class=\"line\">           <span class=\"keyword\">return</span> (T) childView;</div><div class=\"line\">       &#125;</div><div class=\"line\">  </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setText</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, String text)</span> </span>&#123;</div><div class=\"line\">           TextView textView = getView(resId);</div><div class=\"line\">           textView.setText(text);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, <span class=\"keyword\">int</span> colorId)</span> </span>&#123;</div><div class=\"line\">           TextView textView = getView(resId);</div><div class=\"line\">           textView.setTextColor(colorId);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"keyword\">int</span> viewId, <span class=\"keyword\">int</span> drawableId)</span> </span>&#123;</div><div class=\"line\">           ImageView imageView = getView(viewId);</div><div class=\"line\">           imageView.setImageResource(drawableId);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setImageBitmap</span><span class=\"params\">(<span class=\"keyword\">int</span> viewId, Bitmap bm)</span> </span>&#123;</div><div class=\"line\">           ImageView view = getView(viewId);</div><div class=\"line\">           view.setImageBitmap(bm);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"meta\">@Override</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (iOnItemClickListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"comment\">// 此处需要注意如何获取 itemView 的位置</span></div><div class=\"line\">               iOnItemClickListener.onClick(itemView, <span class=\"keyword\">this</span>.getAdapterPosition());</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IOnItemClickListener</span> </span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View view, <span class=\"keyword\">int</span> position)</span></span>;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>这里我们在 onClick()  这个点击事件的方法中不要实现具体的点击逻辑，抽象成一个接口留给实现类去实现。这里我们在 onClick()  中是调用了 iOnItemClickListener 接口的 onClick()  方法。之后在 adapter  中提供调用该接口的方法供实现类去使用。</p>\n<blockquote>\n<p>这里我们可以发现在上面自定义的 viewholder 中，我们添加了一些常用的方法例如：setText()  等。可根据自身项目的实际情况逐渐的去完善这些常用的方法，最终形成自己的独有的 viewholder 。</p>\n</blockquote>\n<h3 id=\"step2-onBindViewHolder-方法\"><a href=\"#step2-onBindViewHolder-方法\" class=\"headerlink\" title=\"step2  onBindViewHolder()  方法\"></a>step2  onBindViewHolder()  方法</h3><p>这个方法在官方的 adapter  中是通过 viewholder  来把 itemView  中的子 View  与其数据绑定在一起。这里我们开发通用的 adapter  不知道运行时子 View 的类型，需要使用抽象的方法把具体的实现交给子类去完成。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(RecyclerView.ViewHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (dataList == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           bindDataList(resId, dataList);<span class=\"comment\">// 由子类 adapter 决定具体如何绑定</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这里的 <code>bindDataList()</code>  是一个抽象方法，留给子类具体去实现具体的子 View  绑定具体的数据。</p>\n</blockquote>\n<h3 id=\"step3-onItemCount-方法\"><a href=\"#step3-onItemCount-方法\" class=\"headerlink\" title=\"step3   onItemCount()  方法\"></a>step3   onItemCount()  方法</h3><p>获得数据的数量，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> dataList == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : dataList.size();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>以上就完成了我们通用 RecyclerviewAdapter 的开发了。下面是所有的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonRecyclerAdapter</span>&lt;<span class=\"title\">Data</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> Context context;</div><div class=\"line\">    <span class=\"keyword\">private</span> IOnItemClickListener iOnItemClickListener = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> resId;<span class=\"comment\">// item 布局id</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Data&gt; dataList;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommonRecyclerAdapter</span><span class=\"params\">(Context context, <span class=\"keyword\">int</span> resId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(context, resId, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommonRecyclerAdapter</span><span class=\"params\">(Context context, <span class=\"keyword\">int</span> resId, List&lt;Data&gt; dataList)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">        <span class=\"keyword\">this</span>.resId = resId;</div><div class=\"line\">        <span class=\"keyword\">this</span>.dataList = dataList;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnItemClickListener</span><span class=\"params\">(IOnItemClickListener iOnItemClickListener)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.iOnItemClickListener = iOnItemClickListener;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDataList</span><span class=\"params\">(List&lt;Data&gt; dataList)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.dataList = dataList;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clearDataList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dataList != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            dataList.clear();</div><div class=\"line\">            notifyDataSetChanged();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Data&gt; <span class=\"title\">getDataList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dataList != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> dataList;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addDataList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dataList == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">this</span>.dataList.addAll(dataList);</div><div class=\"line\">        notifyDataSetChanged();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">bindDataList</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, List&lt;Data&gt; dataList)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> RecyclerView.<span class=\"function\">ViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyViewHolder(context, LayoutInflater.from(context).inflate(resId, parent, <span class=\"keyword\">false</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(RecyclerView.ViewHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dataList == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            bindDataList(resId, dataList);<span class=\"comment\">// 由子类 adapter 决定具体如何绑定</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> dataList == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : dataList.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyViewHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnClickListener</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> Context context = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyViewHolder</span><span class=\"params\">(Context context, View itemView)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(itemView);</div><div class=\"line\">            <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> &lt;T extends View&gt; <span class=\"function\">T <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</div><div class=\"line\">            View childView = itemView.findViewById(resId);</div><div class=\"line\">            <span class=\"keyword\">return</span> (T) childView;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//================= 以下为常用方法可自行增加 =======================</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setText</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, String text)</span> </span>&#123;</div><div class=\"line\">            TextView textView = getView(resId);</div><div class=\"line\">            textView.setText(text);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, <span class=\"keyword\">int</span> colorId)</span> </span>&#123;</div><div class=\"line\">            TextView textView = getView(resId);</div><div class=\"line\">            textView.setTextColor(colorId);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"keyword\">int</span> viewId, <span class=\"keyword\">int</span> drawableId)</span> </span>&#123;</div><div class=\"line\">            ImageView imageView = getView(viewId);</div><div class=\"line\">            imageView.setImageResource(drawableId);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> MyViewHolder <span class=\"title\">setImageBitmap</span><span class=\"params\">(<span class=\"keyword\">int</span> viewId, Bitmap bm)</span> </span>&#123;</div><div class=\"line\">            ImageView view = getView(viewId);</div><div class=\"line\">            view.setImageBitmap(bm);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//=================================================================</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (iOnItemClickListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 此处需要注意如何获取 itemView 的位置</span></div><div class=\"line\">                iOnItemClickListener.onClick(itemView, <span class=\"keyword\">this</span>.getAdapterPosition());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IOnItemClickListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View view, <span class=\"keyword\">int</span> position)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>使用的时候自定义一个 recyclerviewAdapter 继承这个通用的 adapter  实现父类的抽象方法（数据绑定）即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRecyclerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">CommonRecyclerAdapter</span>&lt;<span class=\"title\">Subject</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyRecyclerAdapter</span><span class=\"params\">(Context context, <span class=\"keyword\">int</span> resId)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(context, resId);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bindDataList</span><span class=\"params\">(MyViewHolder holder, <span class=\"keyword\">int</span> position, Subject itemData)</span> </span>&#123;</div><div class=\"line\">            holder.setText(R.id.tv_title_movie, itemData.getTitle());</div><div class=\"line\">            holder.setImageResource(context, R.id.iv_cover_movie, itemData.getImages().getMedium(), R.mipmap.ic_launcher);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>剩下的就是跟官方使用方式一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">movieLv = (RecyclerView) findViewById(R.id.lv_pic_movie);</div><div class=\"line\">movieLv.setLayoutManager(<span class=\"keyword\">new</span> LinearLayoutManager(context));</div><div class=\"line\">myRecyclerAdapter = <span class=\"keyword\">new</span> MyRecyclerAdapter(context, R.layout.item_list_layout);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">myRecyclerAdapter.setDataList(subjects);</div><div class=\"line\">movieLv.setAdapter(myRecyclerAdapter);</div></pre></td></tr></table></figure>\n","slug":"开发RecyclerViewAdapter简化日常开发","updated":"2017-07-10T14:15:34.916Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2017/07/10/开发RecyclerViewAdapter简化日常开发/","excerpt":"","categories":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"https://jngoogle.github.io/tags/View/"}]},{"title":"双重检查锁定以及IoDH探究","date":"2017-07-01T06:36:08.000Z","path":"2017/07/01/双重检查锁定以及IoDH探究/","text":"在上一篇中《创建型模式之单例模式》中提到的双重检查锁定以及 IoDH 这两种方式我们有必要好好的去深入探究一下。 双重检查锁定中的 volatile为什么在双重检查锁定中需要使用 volatile 这个关键字？我们先来看看下面代码的问题就能明白它的作用了。 12345678910111213141516public class SingleInstance &#123; private static SingleInstance sInstance = null; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; synchronized (SingleInstance.class) &#123; if (null == sInstance) &#123; sInstance = new SingleInstance();//问题在这里出现 &#125; &#125; &#125; return sInstance; &#125;&#125; 这是一段没有使用 volatile 的代码块。我们来看看如果没有使用 volatile 的双重检查锁定会出现什么问题。 假设现在有线程 A 和 B，同时要调用上面的代码块。 现在假设 A 线程先调用了上面的代码获得线程锁 synchronized。B 线程则停留在外层的 null ==sInstance 判断处，去检查有没有实例，如果 A 线程已经创建好了实例此时 B 线程直接返回该实例即可；若没有实例则 B 获取线程锁创建一个实例。 看起来上面的逻辑很正常没有问题，但是实际情况是：在 A 线程创建实例的时候，也就是我们代码的第10行，真正创建实例的过程可能并不是我们所想当然的那么简单。 在 new 一个实例的时候在 A 线程中经历了如下的操作： 分配内存空间 初始化对象 设置对象指向分配的内存空间地址 但是实际情况确实，在上面的三个步骤中其实第二步与第三步是可能对调顺序的。也就是说可能执行的顺序是132，这样的顺序。你可以参考 Double-checked locking and the Singleton pattern 中 Out-of-order writes 的部分。 根据 java 语言规范，所有线程在执行java程序时必须要遵守 intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话来说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面三行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序的执行结果的前提下，可以提高程序的执行性能。 如果顺序变成了132会导致什么结果呢？","raw":"---\ntitle: 双重检查锁定以及IoDH探究\ndate: 2017-07-01 14:36:08\ncategories: 设计模式\ntags: \n- 设计模式\n- 单例模式\n---\n\n在上一篇中《创建型模式之单例模式》中提到的双重检查锁定以及 IoDH 这两种方式我们有必要好好的去深入探究一下。\n\n<br>\n\n### 双重检查锁定中的 volatile  \n\n为什么在双重检查锁定中需要使用 volatile 这个关键字？我们先来看看下面代码的问题就能明白它的作用了。\n\n```java\npublic class SingleInstance {\n  private static SingleInstance sInstance = null;\n  private SingleInstance() {\n  }\n  \n  public static SingleInstance getInstance() {\n      if (null == sInstance) {\n          synchronized (SingleInstance.class) {\n              if (null == sInstance) {\n                  sInstance = new SingleInstance();//问题在这里出现\n              }\n          }\n      }\n      return sInstance;\n  }\n}\n```\n\n这是一段没有使用 volatile 的代码块。我们来看看如果没有使用 volatile 的双重检查锁定会出现什么问题。\n\n> 假设现在有线程 A  和  B，同时要调用上面的代码块。\n>\n> 现在假设 A 线程先调用了上面的代码获得线程锁 synchronized。B 线程则停留在外层的 `null ==sInstance `  判断处，去检查有没有实例，如果 A 线程已经创建好了实例此时 B 线程直接返回该实例即可；若没有实例则 B 获取线程锁创建一个实例。\n\n看起来上面的逻辑很正常没有问题，但是实际情况是：在 A 线程创建实例的时候，也就是我们代码的第10行，真正创建实例的过程可能并不是我们所想当然的那么简单。\n\n<br>\n\n在 new 一个实例的时候在 A  线程中经历了如下的操作：\n\n1. 分配内存空间\n2. 初始化对象\n3. 设置对象指向分配的内存空间地址\n\n但是实际情况确实，在上面的三个步骤中其实第二步与第三步是可能对调顺序的。也就是说可能执行的顺序是132，这样的顺序。*你可以参考  [Double-checked locking and the Singleton pattern](https://www.ibm.com/developerworks/java/library/j-dcl/index.html) 中 Out-of-order writes 的部分。*\n\n> 根据 java 语言规范，所有线程在执行java程序时必须要遵守 intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话来说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面三行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序的执行结果的前提下，可以提高程序的执行性能。\n\n\n\n<br>\n\n**如果顺序变成了132会导致什么结果呢？**\n\n<br>\n\n","content":"<p>在上一篇中《创建型模式之单例模式》中提到的双重检查锁定以及 IoDH 这两种方式我们有必要好好的去深入探究一下。</p>\n<p><br></p>\n<h3 id=\"双重检查锁定中的-volatile\"><a href=\"#双重检查锁定中的-volatile\" class=\"headerlink\" title=\"双重检查锁定中的 volatile\"></a>双重检查锁定中的 volatile</h3><p>为什么在双重检查锁定中需要使用 volatile 这个关键字？我们先来看看下面代码的问题就能明白它的作用了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstance</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingleInstance sInstance = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleInstance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == sInstance) &#123;</div><div class=\"line\">          <span class=\"keyword\">synchronized</span> (SingleInstance.class) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == sInstance) &#123;</div><div class=\"line\">                  sInstance = <span class=\"keyword\">new</span> SingleInstance();<span class=\"comment\">//问题在这里出现</span></div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是一段没有使用 volatile 的代码块。我们来看看如果没有使用 volatile 的双重检查锁定会出现什么问题。</p>\n<blockquote>\n<p>假设现在有线程 A  和  B，同时要调用上面的代码块。</p>\n<p>现在假设 A 线程先调用了上面的代码获得线程锁 synchronized。B 线程则停留在外层的 <code>null ==sInstance</code>  判断处，去检查有没有实例，如果 A 线程已经创建好了实例此时 B 线程直接返回该实例即可；若没有实例则 B 获取线程锁创建一个实例。</p>\n</blockquote>\n<p>看起来上面的逻辑很正常没有问题，但是实际情况是：在 A 线程创建实例的时候，也就是我们代码的第10行，真正创建实例的过程可能并不是我们所想当然的那么简单。</p>\n<p><br></p>\n<p>在 new 一个实例的时候在 A  线程中经历了如下的操作：</p>\n<ol>\n<li>分配内存空间</li>\n<li>初始化对象</li>\n<li>设置对象指向分配的内存空间地址</li>\n</ol>\n<p>但是实际情况确实，在上面的三个步骤中其实第二步与第三步是可能对调顺序的。也就是说可能执行的顺序是132，这样的顺序。<em>你可以参考  <a href=\"https://www.ibm.com/developerworks/java/library/j-dcl/index.html\" target=\"_blank\" rel=\"external\">Double-checked locking and the Singleton pattern</a> 中 Out-of-order writes 的部分。</em></p>\n<blockquote>\n<p>根据 java 语言规范，所有线程在执行java程序时必须要遵守 intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话来说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面三行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序的执行结果的前提下，可以提高程序的执行性能。</p>\n</blockquote>\n<p><br></p>\n<p><strong>如果顺序变成了132会导致什么结果呢？</strong></p>\n<p><br></p>\n","slug":"双重检查锁定以及IoDH探究","updated":"2017-07-10T07:23:06.145Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2017/07/01/双重检查锁定以及IoDH探究/","excerpt":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jngoogle.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://jngoogle.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://jngoogle.github.io/tags/单例模式/"}]},{"title":"创建型模式之单例模式","date":"2017-06-29T13:15:11.000Z","path":"2017/06/29/创建型模式之单例模式/","text":"前言 ps: 本文较长，请分段阅读 上图列举出来所有设计模式的结构图，这次就来看看单例模式。 在软件设计中，许多地方用到的实例是不需要创建多个实例，例如在 Windows 系统中有且仅有一个任务管理器（它也确实不需要多个，并且如果有多个将出现很多问题）。不管是实际情况的需要还是为了提高性能，当我们只需要一个实例的时候就可以使用单例模式来设计。 我们就从日常开发中使用最多的 单例模式 开始我们的设计模式学习。 单例模式的定义单例模式的定义是：确保某一个类只有一个实例，并自行实例化且向整个系统提供这个实例。 只有一个实例 必须是自行实例化 提供全局访问的方法 如何实现单例模式第1步创建一个类假设是 SingleInstance，然后保证它的构造方法（无参数）的访问权限是 private ，避免外部类使用 new 创建多个实例（此时外部类无法使用 new 来创建该单例）。 第2步创建 SingleInstance中的成员变量假设是 sInstance（类型是 SingleInstance） ，使用 private 和 static 进行修饰即私有的静态变量，保证其是该 单例的唯一实例。 第3步在 SingleInstance类中创建一个 public 修饰的公共方法 getInstance ，提供给外部类调用该方法来引用这个单例。 具体实现方式实现单例模式有几种不同的方法，下面逐一来看看这几种使用单例的方式。 #饿汉式方法特点： 直接在类中 new 出成员变量。 12345678910public class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 这种实现方式由于直接 new 出了成员变量，所以在类被加载的时候同时就会创建该单例。在 getInstance 方法中就可以直接返回 sInstance 这个单例。 需要注意的是创建该类的构造方法的时候要使用 private 修饰，保证外部类不可以使用 new 来创建多个实例。 总结： 当单例类构造方法比较简单，逻辑不复杂的时候可以采用（但是并不推荐），一般来说开发的过程中不要使用 饿汉式 来实现单例模式。 如果类的构造方法复杂，可能会导致类加载很慢。 类加载的时候没有真正的调用，浪费内存资源。 #懒汉式为了解决 饿汉式 存在的问题，我们可以采用懒汉式的方式来实现单例模式。 方法特点： 不直接在类中 new 出成员变量。 123456789101112public class SingleInstance &#123; private static SingleInstance sInstance = null; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 该方法解决掉了之前 饿汉式 的性能问题，但是当处于多个线程的时候我们使用上述代码会出现一个严重的问题。嗯，聚个栗子： 现在有两个线程分别为 A 线程、B 线程（简称 A 和 B）。 当 A 执行上面的代码，第一次实例化的时候判断 sInstance 是否为 null，现在为 null 则在 A 中开始创建 SingleInstance 如果创建这个类需要很长的时间,在这个时候 B 线程也执行了上面的代码。B 线程中由于在 A 中的实例还在创建中没有完成，所以 B 中会判断 sInstance 为 null，然后也开始创建实例了。这就导致创建了两个实例，不符合单例模式的设计。 要解决这个问题就是让 A 在执行上面代码的时候，B 线程不能执行直到 A 执行完成了。这样 B 再执行的时候 sInstance 就不是 null 了，自然也就不会再创建新的实例了。 使用线程锁就可以实现上述过程，所以我们修改代码如下： 123456789101112public class SingleInstance &#123; private static SingleInstance sInstance = null; private SingleInstance() &#123; &#125; synchronized public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized 是可以保证多线程、单一实例的方法。有了这个线程锁，很多线程都要执行上面代码的时候就必须要排队，一个一个的来。前面的线程没有使用完这个方法，后面来的线程是没有权限执行这个方法的。 ok，一般开发中大家可能都是使用的 懒汉式 这种实现方式。 但是有一个问题。如果多个线程都要执行这块代码，当第一个线程执行完了这块代码创建了实例。后面的线程才能执行代码去获取 synchronized 这个线程锁，注意获取它是一个耗时操作，但是此时实例已经创建了其实已经没有必要再去获取线程锁了。这里就造成了性能低下的问题。 总结： 通过使用 synchronized 解决了多线程的问题但是此方式效率并不高，不推荐。 #双重检查锁定方式 double-checked locking由于获取线程锁 synchronized 是一个耗时的操作，要解决 懒汉式 的问题出现了 双重检查锁定的方式。 该方法的思路也很简单，就是如果这个实例由前面的线程创建了的话，后面的线程在执行代码的时候先判断有没有这个实例，如果有了就不去获取线程锁直接返回已经创建好的实例；没有的话才会去创建实例。 12345678910111213141516public class SingleInstance &#123; private static volatile SingleInstance sInstance = null; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; synchronized (SingleInstance.class) &#123; if (null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; 代码中可以很清除的看到在 getInstance() 方法中，首先是判断 sInstance 是否为 null 。假设现在 A 和 B 两个线程，现在是 A 先执行上面的代码假设 A 已经创建好了实例，当 B 进入 getInstance() 方法后，先判断实例是否已经存在，此时是存在的所以不需要获取线程锁去创建实例直接返回实例即可。这样后面的线程不需要去获得线程锁大大提高了执行的效率。 可能你会问为什么需要双重检查？ 在 Synchronized 中为什么还需要判断实例是否为空呢？我们举个比较特殊的 同样我们有两个线程 A 和 B。现在我们假设这两个线程同时调用该方法（现在是可以同时调用 getInstance() 方法的，由于没有 synchronized 线程锁）。两个线程同时进入 getInstance() 方法同时在判断实例是否为空，好，此时都判断为空，这个时候假定 A 先获得了线程锁进入方法中去创建实例。当创建完成之后，A 释放，B 获得线程锁进入方法，如果这个时候不判断实例是否存在，则 B 就会创建实例，最终就有了两个实例了。 ok, 解决了双重检查的问题最最重要的一点还没有提到就是 volatile 这个东西了。 注意在 SingleInstance 类中定义成员变量 sInstance 的时候是用了这个词的。那 volatile 是什么呢？这个具体等下下一篇来说，因为内容较多就不放在这一篇里了，不过你可以去参考一下 这里。 #IoDH 方式饿汉式不能实现延迟加载，不管使用与否都将占用内存；懒汉式线程安全需要去控制线程锁比较麻烦。那么现在还有一种方式来同时有两种方式的优点并且去掉他们的缺陷！它被称为 Initialization Demand Holder（IoDH）方式。 123456789101112public class SingleInstance &#123; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return SingleInstanceHolder.sInstance; &#125; private static class SingleInstanceHolder &#123; private static SingleInstance sInstance = new SingleInstance(); &#125;&#125; 在类中创建了一个静态持有类 SingleInstanceHolder 。利用静态类在被加载的时候才会创建的特性，故当 SingleInstance类被加载的时候，如果此时没有加载 SingleInstanceHolder 则该类并不会被加载。这样就能保证在类没有被调用的时候不会占用内存。我们在公有方法中通过该类引用到单例实例。 总结： IoDH 方式综合了了饿汉式 和 懒汉式 两种方式的优点同时也避免了缺陷。 参考链接 《设计模式 java 版》- sunny Double-checked locking and the Singleton pattern 单例这种设计模式 - 技术小黑屋","raw":"---\ntitle: 创建型模式之单例模式\ndate: 2017-06-29 21:15:11\ncategories: 设计模式\ntags: \n- 设计模式\n- 单例模式\n---\n\n# 前言\n\n> ps: 本文较长，请分段阅读\n\n![设计模式结构图](http://imglf1.nosdn.127.net/img/R3RmT3FSa2l4djRyQmgrU2R2VUpwN0Z2ME9OZUlEdnZGMkN4bFhwYVBDdlpveitaYXZUZ21BPT0.png?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg%7Cwatermark&type=2&text=wqkg5ZOO5ZGm5LiN6ZSZ5ZOfIC8gamFtbWljbmljb29sZS5sb2Z0ZXIuY29t&font=bXN5aA==&gravity=southwest&dissolve=30&fontsize=240&dx=8&dy=10&stripmeta=0)\n\n\n\n上图列举出来所有设计模式的结构图，这次就来看看单例模式。\n\n在软件设计中，许多地方用到的实例是不需要创建多个实例，例如在 Windows 系统中有且仅有一个任务管理器（*它也确实不需要多个，并且如果有多个将出现很多问题*）。不管是实际情况的需要还是为了提高性能，当我们只需要一个实例的时候就可以使用单例模式来设计。\n\n我们就从日常开发中使用最多的 单例模式 开始我们的设计模式学习。\n\n\n\n### 单例模式的定义\n\n单例模式的定义是：**确保某一个类只有一个实例，并自行实例化且向整个系统提供这个实例**。\n\n- 只有一个实例\n- 必须是自行实例化\n- 提供全局访问的方法\n\n### 如何实现单例模式\n\n#### 第1步\n\n创建一个类假设是 SingleInstance，然后保证它的构造方法（*无参数*）的访问权限是 private ，避免外部类使用 new 创建多个实例（此时外部类无法使用 new 来创建该单例）。\n\n#### 第2步\n\n创建 SingleInstance中的成员变量假设是 sInstance（*类型是 SingleInstance*） ，使用 private 和 static 进行修饰即私有的静态变量，保证其是该 单例的唯一实例。\n\n#### 第3步\n\n在 SingleInstance类中创建一个 public 修饰的公共方法 getInstance ，提供给外部类调用该方法来引用这个单例。\n\n\n\n### 具体实现方式\n\n实现单例模式有几种不同的方法，下面逐一来看看这几种使用单例的方式。\n\n#### #饿汉式\n\n**方法特点：** 直接在类中 new 出成员变量。\n\n```java\npublic class SingleInstance {\n  private static SingleInstance sInstance = new SingleInstance();\n  \n  private SingleInstance() {\n  }\n  \n  public static SingleInstance getInstance() {\n      return sInstance;\n  }\n}\n```\n\n这种实现方式由于直接 new 出了成员变量，所以在类被加载的时候同时就会创建该单例。在 getInstance 方法中就可以直接返回 sInstance 这个单例。\n\n**需要注意的是创建该类的构造方法的时候要使用 private 修饰，保证外部类不可以使用 new 来创建多个实例。**\n\n总结：\n\n- 当单例类构造方法比较简单，逻辑不复杂的时候可以采用（*但是并不推荐*），一般来说开发的过程中不要使用 饿汉式 来实现单例模式。 \n- 如果类的构造方法复杂，可能会导致类加载很慢。\n- 类加载的时候没有真正的调用，浪费内存资源。\n\n<br>\n\n#### #懒汉式\n\n为了解决 饿汉式 存在的问题，我们可以采用懒汉式的方式来实现单例模式。\n\n**方法特点：** 不直接在类中 new 出成员变量。\n\n```java\npublic class SingleInstance {\n  private static SingleInstance sInstance = null;\n  private SingleInstance() {\n  }\n  \n  public static SingleInstance getInstance() {\n      if (null == sInstance) {\n          sInstance = new SingleInstance();\n      }\n      return sInstance;\n  }\n}\n```\n\n该方法解决掉了之前 饿汉式 的性能问题，但是当处于多个线程的时候我们使用上述代码会出现一个严重的问题。嗯，聚个栗子：\n\n> 现在有两个线程分别为 A 线程、B 线程（*简称 A 和 B*）。 \n>\n> 当 A 执行上面的代码，第一次实例化的时候判断 sInstance 是否为 null，现在为 null 则在 A 中开始创建 SingleInstance 如果创建这个类需要很长的时间,在这个时候 B 线程也执行了上面的代码。B 线程中由于在 A 中的实例还在创建中没有完成，所以 B 中会判断 sInstance 为 null，然后也开始创建实例了。这就导致创建了两个实例，不符合单例模式的设计。\n\n要解决这个问题就是让 A 在执行上面代码的时候，B 线程不能执行直到 A 执行完成了。这样 B 再执行的时候 sInstance 就不是 null 了，自然也就不会再创建新的实例了。\n\n使用线程锁就可以实现上述过程，所以我们修改代码如下：\n\n```java\npublic class SingleInstance {\n  private static SingleInstance sInstance = null;\n  private SingleInstance() {\n  }\n  \n  synchronized public static SingleInstance getInstance() {\n      if (null == sInstance) {\n          sInstance = new SingleInstance();\n      }\n      return sInstance;\n  }\n}\n```\n\n`synchronized`  是可以保证多线程、单一实例的方法。有了这个线程锁，很多线程都要执行上面代码的时候就必须要排队，一个一个的来。前面的线程没有使用完这个方法，后面来的线程是没有权限执行这个方法的。\n\nok，一般开发中大家可能都是使用的 懒汉式 这种实现方式。\n\n但是有一个问题。如果多个线程都要执行这块代码，当第一个线程执行完了这块代码创建了实例。后面的线程才能执行代码去获取  `synchronized`  这个线程锁，注意获取它是一个耗时操作，但是此时实例已经创建了其实已经没有必要再去获取线程锁了。这里就造成了性能低下的问题。\n\n总结：\n\n- 通过使用 `synchronized`   解决了多线程的问题但是此方式效率并不高，不推荐。\n\n<br>\n\n#### #双重检查锁定方式   double-checked locking\n\n由于获取线程锁 `synchronized`    是一个耗时的操作，要解决 懒汉式 的问题出现了 双重检查锁定的方式。\n\n该方法的思路也很简单，就是如果这个实例由前面的线程创建了的话，后面的线程在执行代码的时候先判断有没有这个实例，如果有了就不去获取线程锁直接返回已经创建好的实例；没有的话才会去创建实例。\n\n```java\npublic class SingleInstance {\n  private static volatile SingleInstance sInstance = null;\n  private SingleInstance() {\n  }\n  \n  public static SingleInstance getInstance() {\n      if (null == sInstance) {\n          synchronized (SingleInstance.class) {\n              if (null == sInstance) {\n                  sInstance = new SingleInstance();\n              }\n          }\n      }\n      return sInstance;\n  }\n}\n```\n\n代码中可以很清除的看到在  getInstance() 方法中，首先是判断 sInstance 是否为 null 。假设现在 A  和 B  两个线程，现在是 A  先执行上面的代码假设 A 已经创建好了实例，当 B  进入  getInstance() 方法后，先判断实例是否已经存在，此时是存在的所以不需要获取线程锁去创建实例直接返回实例即可。这样后面的线程不需要去获得线程锁大大提高了执行的效率。\n\n**可能你会问为什么需要双重检查？**\n\n在 Synchronized 中为什么还需要判断实例是否为空呢？我们举个比较特殊的\n\n> 同样我们有两个线程 A  和 B。现在我们假设这两个线程同时调用该方法（*现在是可以同时调用 getInstance() 方法的，由于没有 synchronized 线程锁*）。两个线程同时进入 getInstance() 方法同时在判断实例是否为空，好，此时都判断为空，这个时候假定 A 先获得了线程锁进入方法中去创建实例。当创建完成之后，A 释放，B 获得线程锁进入方法，如果这个时候不判断实例是否存在，则 B  就会创建实例，最终就有了两个实例了。\n\nok, 解决了双重检查的问题最最重要的一点还没有提到就是 volatile  这个东西了。\n\n注意在 SingleInstance 类中定义成员变量 sInstance 的时候是用了这个词的。那 volatile 是什么呢？这个具体等下下一篇来说，因为内容较多就不放在这一篇里了，不过你可以去参考一下 [这里。](https://www.ibm.com/developerworks/java/library/j-dcl/index.html)\n\n<br>\n\n#### #IoDH 方式\n\n饿汉式不能实现延迟加载，不管使用与否都将占用内存；懒汉式线程安全需要去控制线程锁比较麻烦。那么现在还有一种方式来同时有两种方式的优点并且去掉他们的缺陷！它被称为 Initialization Demand Holder（IoDH）方式。\n\n```java\npublic class SingleInstance {\n  private SingleInstance() {\n  }\n  \n  public static SingleInstance getInstance() {\n      return SingleInstanceHolder.sInstance;\n  }\n  \n  private static class SingleInstanceHolder {\n      private static SingleInstance sInstance = new SingleInstance();\n  }\n}\n```\n\n在类中创建了一个静态持有类  SingleInstanceHolder 。利用静态类在被加载的时候才会创建的特性，故当 SingleInstance类被加载的时候，如果此时没有加载 SingleInstanceHolder 则该类并不会被加载。这样就能保证在类没有被调用的时候不会占用内存。我们在公有方法中通过该类引用到单例实例。\n\n总结：\n\n- IoDH 方式综合了了饿汉式 和 懒汉式 两种方式的优点同时也避免了缺陷。\n\n\n\n# 参考链接\n\n [《设计模式 java 版》](https://gof.quanke.name/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html)- sunny\n\n[Double-checked locking and the Singleton pattern](https://www.ibm.com/developerworks/java/library/j-dcl/index.html)\n\n[单例这种设计模式](http://droidyue.com/blog/2015/01/11/looking-into-singleton/) - 技术小黑屋","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>ps: 本文较长，请分段阅读</p>\n</blockquote>\n<p><img src=\"http://imglf1.nosdn.127.net/img/R3RmT3FSa2l4djRyQmgrU2R2VUpwN0Z2ME9OZUlEdnZGMkN4bFhwYVBDdlpveitaYXZUZ21BPT0.png?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2&amp;text=wqkg5ZOO5ZGm5LiN6ZSZ5ZOfIC8gamFtbWljbmljb29sZS5sb2Z0ZXIuY29t&amp;font=bXN5aA==&amp;gravity=southwest&amp;dissolve=30&amp;fontsize=240&amp;dx=8&amp;dy=10&amp;stripmeta=0\" alt=\"设计模式结构图\"></p>\n<p>上图列举出来所有设计模式的结构图，这次就来看看单例模式。</p>\n<p>在软件设计中，许多地方用到的实例是不需要创建多个实例，例如在 Windows 系统中有且仅有一个任务管理器（<em>它也确实不需要多个，并且如果有多个将出现很多问题</em>）。不管是实际情况的需要还是为了提高性能，当我们只需要一个实例的时候就可以使用单例模式来设计。</p>\n<p>我们就从日常开发中使用最多的 单例模式 开始我们的设计模式学习。</p>\n<h3 id=\"单例模式的定义\"><a href=\"#单例模式的定义\" class=\"headerlink\" title=\"单例模式的定义\"></a>单例模式的定义</h3><p>单例模式的定义是：<strong>确保某一个类只有一个实例，并自行实例化且向整个系统提供这个实例</strong>。</p>\n<ul>\n<li>只有一个实例</li>\n<li>必须是自行实例化</li>\n<li>提供全局访问的方法</li>\n</ul>\n<h3 id=\"如何实现单例模式\"><a href=\"#如何实现单例模式\" class=\"headerlink\" title=\"如何实现单例模式\"></a>如何实现单例模式</h3><h4 id=\"第1步\"><a href=\"#第1步\" class=\"headerlink\" title=\"第1步\"></a>第1步</h4><p>创建一个类假设是 SingleInstance，然后保证它的构造方法（<em>无参数</em>）的访问权限是 private ，避免外部类使用 new 创建多个实例（此时外部类无法使用 new 来创建该单例）。</p>\n<h4 id=\"第2步\"><a href=\"#第2步\" class=\"headerlink\" title=\"第2步\"></a>第2步</h4><p>创建 SingleInstance中的成员变量假设是 sInstance（<em>类型是 SingleInstance</em>） ，使用 private 和 static 进行修饰即私有的静态变量，保证其是该 单例的唯一实例。</p>\n<h4 id=\"第3步\"><a href=\"#第3步\" class=\"headerlink\" title=\"第3步\"></a>第3步</h4><p>在 SingleInstance类中创建一个 public 修饰的公共方法 getInstance ，提供给外部类调用该方法来引用这个单例。</p>\n<h3 id=\"具体实现方式\"><a href=\"#具体实现方式\" class=\"headerlink\" title=\"具体实现方式\"></a>具体实现方式</h3><p>实现单例模式有几种不同的方法，下面逐一来看看这几种使用单例的方式。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"#饿汉式\"></a>#饿汉式</h4><p><strong>方法特点：</strong> 直接在类中 new 出成员变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstance</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingleInstance sInstance = <span class=\"keyword\">new</span> SingleInstance();</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleInstance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种实现方式由于直接 new 出了成员变量，所以在类被加载的时候同时就会创建该单例。在 getInstance 方法中就可以直接返回 sInstance 这个单例。</p>\n<p><strong>需要注意的是创建该类的构造方法的时候要使用 private 修饰，保证外部类不可以使用 new 来创建多个实例。</strong></p>\n<p>总结：</p>\n<ul>\n<li>当单例类构造方法比较简单，逻辑不复杂的时候可以采用（<em>但是并不推荐</em>），一般来说开发的过程中不要使用 饿汉式 来实现单例模式。 </li>\n<li>如果类的构造方法复杂，可能会导致类加载很慢。</li>\n<li>类加载的时候没有真正的调用，浪费内存资源。</li>\n</ul>\n<p><br></p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"#懒汉式\"></a>#懒汉式</h4><p>为了解决 饿汉式 存在的问题，我们可以采用懒汉式的方式来实现单例模式。</p>\n<p><strong>方法特点：</strong> 不直接在类中 new 出成员变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstance</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingleInstance sInstance = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleInstance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == sInstance) &#123;</div><div class=\"line\">          sInstance = <span class=\"keyword\">new</span> SingleInstance();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法解决掉了之前 饿汉式 的性能问题，但是当处于多个线程的时候我们使用上述代码会出现一个严重的问题。嗯，聚个栗子：</p>\n<blockquote>\n<p>现在有两个线程分别为 A 线程、B 线程（<em>简称 A 和 B</em>）。 </p>\n<p>当 A 执行上面的代码，第一次实例化的时候判断 sInstance 是否为 null，现在为 null 则在 A 中开始创建 SingleInstance 如果创建这个类需要很长的时间,在这个时候 B 线程也执行了上面的代码。B 线程中由于在 A 中的实例还在创建中没有完成，所以 B 中会判断 sInstance 为 null，然后也开始创建实例了。这就导致创建了两个实例，不符合单例模式的设计。</p>\n</blockquote>\n<p>要解决这个问题就是让 A 在执行上面代码的时候，B 线程不能执行直到 A 执行完成了。这样 B 再执行的时候 sInstance 就不是 null 了，自然也就不会再创建新的实例了。</p>\n<p>使用线程锁就可以实现上述过程，所以我们修改代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstance</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingleInstance sInstance = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleInstance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == sInstance) &#123;</div><div class=\"line\">          sInstance = <span class=\"keyword\">new</span> SingleInstance();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>synchronized</code>  是可以保证多线程、单一实例的方法。有了这个线程锁，很多线程都要执行上面代码的时候就必须要排队，一个一个的来。前面的线程没有使用完这个方法，后面来的线程是没有权限执行这个方法的。</p>\n<p>ok，一般开发中大家可能都是使用的 懒汉式 这种实现方式。</p>\n<p>但是有一个问题。如果多个线程都要执行这块代码，当第一个线程执行完了这块代码创建了实例。后面的线程才能执行代码去获取  <code>synchronized</code>  这个线程锁，注意获取它是一个耗时操作，但是此时实例已经创建了其实已经没有必要再去获取线程锁了。这里就造成了性能低下的问题。</p>\n<p>总结：</p>\n<ul>\n<li>通过使用 <code>synchronized</code>   解决了多线程的问题但是此方式效率并不高，不推荐。</li>\n</ul>\n<p><br></p>\n<h4 id=\"双重检查锁定方式-double-checked-locking\"><a href=\"#双重检查锁定方式-double-checked-locking\" class=\"headerlink\" title=\"#双重检查锁定方式   double-checked locking\"></a>#双重检查锁定方式   double-checked locking</h4><p>由于获取线程锁 <code>synchronized</code>    是一个耗时的操作，要解决 懒汉式 的问题出现了 双重检查锁定的方式。</p>\n<p>该方法的思路也很简单，就是如果这个实例由前面的线程创建了的话，后面的线程在执行代码的时候先判断有没有这个实例，如果有了就不去获取线程锁直接返回已经创建好的实例；没有的话才会去创建实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstance</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingleInstance sInstance = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleInstance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == sInstance) &#123;</div><div class=\"line\">          <span class=\"keyword\">synchronized</span> (SingleInstance.class) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == sInstance) &#123;</div><div class=\"line\">                  sInstance = <span class=\"keyword\">new</span> SingleInstance();</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码中可以很清除的看到在  getInstance() 方法中，首先是判断 sInstance 是否为 null 。假设现在 A  和 B  两个线程，现在是 A  先执行上面的代码假设 A 已经创建好了实例，当 B  进入  getInstance() 方法后，先判断实例是否已经存在，此时是存在的所以不需要获取线程锁去创建实例直接返回实例即可。这样后面的线程不需要去获得线程锁大大提高了执行的效率。</p>\n<p><strong>可能你会问为什么需要双重检查？</strong></p>\n<p>在 Synchronized 中为什么还需要判断实例是否为空呢？我们举个比较特殊的</p>\n<blockquote>\n<p>同样我们有两个线程 A  和 B。现在我们假设这两个线程同时调用该方法（<em>现在是可以同时调用 getInstance() 方法的，由于没有 synchronized 线程锁</em>）。两个线程同时进入 getInstance() 方法同时在判断实例是否为空，好，此时都判断为空，这个时候假定 A 先获得了线程锁进入方法中去创建实例。当创建完成之后，A 释放，B 获得线程锁进入方法，如果这个时候不判断实例是否存在，则 B  就会创建实例，最终就有了两个实例了。</p>\n</blockquote>\n<p>ok, 解决了双重检查的问题最最重要的一点还没有提到就是 volatile  这个东西了。</p>\n<p>注意在 SingleInstance 类中定义成员变量 sInstance 的时候是用了这个词的。那 volatile 是什么呢？这个具体等下下一篇来说，因为内容较多就不放在这一篇里了，不过你可以去参考一下 <a href=\"https://www.ibm.com/developerworks/java/library/j-dcl/index.html\" target=\"_blank\" rel=\"external\">这里。</a></p>\n<p><br></p>\n<h4 id=\"IoDH-方式\"><a href=\"#IoDH-方式\" class=\"headerlink\" title=\"#IoDH 方式\"></a>#IoDH 方式</h4><p>饿汉式不能实现延迟加载，不管使用与否都将占用内存；懒汉式线程安全需要去控制线程锁比较麻烦。那么现在还有一种方式来同时有两种方式的优点并且去掉他们的缺陷！它被称为 Initialization Demand Holder（IoDH）方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstance</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleInstance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> SingleInstanceHolder.sInstance;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleInstanceHolder</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingleInstance sInstance = <span class=\"keyword\">new</span> SingleInstance();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在类中创建了一个静态持有类  SingleInstanceHolder 。利用静态类在被加载的时候才会创建的特性，故当 SingleInstance类被加载的时候，如果此时没有加载 SingleInstanceHolder 则该类并不会被加载。这样就能保证在类没有被调用的时候不会占用内存。我们在公有方法中通过该类引用到单例实例。</p>\n<p>总结：</p>\n<ul>\n<li>IoDH 方式综合了了饿汉式 和 懒汉式 两种方式的优点同时也避免了缺陷。</li>\n</ul>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p> <a href=\"https://gof.quanke.name/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html\" target=\"_blank\" rel=\"external\">《设计模式 java 版》</a>- sunny</p>\n<p><a href=\"https://www.ibm.com/developerworks/java/library/j-dcl/index.html\" target=\"_blank\" rel=\"external\">Double-checked locking and the Singleton pattern</a></p>\n<p><a href=\"http://droidyue.com/blog/2015/01/11/looking-into-singleton/\" target=\"_blank\" rel=\"external\">单例这种设计模式</a> - 技术小黑屋</p>\n","slug":"创建型模式之单例模式","updated":"2017-07-10T08:18:59.173Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2017/06/29/创建型模式之单例模式/","excerpt":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jngoogle.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://jngoogle.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://jngoogle.github.io/tags/单例模式/"}]},{"title":"Retrofit + Rxjava 从入门到跑路（Retrofit介绍）","date":"2016-12-29T06:53:19.000Z","path":"2016/12/29/Retrofit-Rxjava-从入门到跑路（Retrofit）/","text":"Retrofit是什么简单的一句话是一个网络库用来处理一些网络上的数据传输。 Type-safe HTTP client for Android and Java by Square, Inc. 适用于Android 和 Java 的类型安全的Http 客户端 如何使用Retrofit一 配置 Retrofit使用 Gradle 方式添加依赖： 12345678// rxAndroidcompile 'io.reactivex:rxandroid:1.0.1'// retrofit2compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'compile 'com.squareup.retrofit2:retrofit:2.0.2'compile 'com.squareup.retrofit2:converter-gson:2.0.2'// network interceptorcompile 'com.squareup.okhttp3:logging-interceptor:3.1.2' 注意 converter-gson 是一个转换器，你还可以在以下转换器中选择（本文使用Gson作为例子）： Gson: com.squareup.retrofit2:converter-gson （google 官方推荐） Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 我们还可以在 gradle 中添加 网络拦截器，方便调试。 添加网络调试：compile &#39;com.squareup.okhttp3:logging-interceptor:3.1.2&#39; 同时如果要使用 rxjava rxAndroid 与 retrofit 搭配使用，需要添加以下依赖 compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39; compile &#39;io.reactivex:rxandroid:1.0.1&#39; 二 创建服务当你完成了 retrofit 的配置之后，就可以开始创建服务请求了。retrofit 通过接口的方式来提供网络上的请求，下面通过简单的例子来看看如何创建服务。 12345public interface IMovieTop250 &#123; @GET(\"v2/movie/top250?\") Observable&lt;JsonResult&lt;List&lt;Subject&gt;&gt;&gt; getMovie(@Query(\"start\") int start, @Query(\"count\") int count);&#125; 这里接上一篇《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》 中的json结果，使用的是豆瓣电影的API Top250 的API，Url 请求长这样：https://api.douban.com/v2/movie/top250?start=0;count=1 1 填写请求地址 我们这样来分解，把 https://api.douban.com/ 作为base_url ，剩下的 v2/movie/top250? 作为这个接口请求的url。前面放上 GET 关键字表示请求的方式。base_url 我们将在 serviceManager 中去处理，后面会提到。 特别提示：base_url 需要以斜杠 / 结尾，否则会报错 2 确定返回类型 写好了请求的地址，我们来写请求返回的参数类型 Observable&lt;JsonResult&lt;List&lt;Subject&gt;&gt;&gt; 表示从 API 返回一个 JsonResult 类型，并且这里使用了 rxjava ，所以是 Observable 而并不是 Call 。 3 填写请求参数（如果需要） 这里我们需要两个参数，采用 Query 关键字，键值对中键的名称分别为 start 和 count 写在括号中，后面写上对应的变量名。 关于请求的关键字如 GET POST 可以去 这里 查看 这里我们看到一个请求地址就对应着一个接口，当然你可以在一个接口中创建多个请求方法（一般用在同一类型的请求但是各个请求的参数有区别的情况）。这里举一个例子： 1234567891011public interface ISubmitService &#123; @POST(\"confirmOrder?\") Observable&lt;SubmitEntity&gt; submitSaleOrder(@Query(\"id\") int id, @Query(\"task_id\") int taskId); @POST(\"confirmOrder?\") Observable&lt;SubmitEntity&gt; submitRepairOrder(@Query(\"id\") int id, @Query(\"task_id\") int taskId, @Query(\"order_id\") int orderId, @Query(\"order_type\") String orderType);&#125; 这个请求接口中两个请求方法只是请求的参数不同而已。完成了以上步骤就创建好了 接口形式的网络请求了。 三 配置你的 ServiceManager当你完成了请求接口的创建之后，我们会使用一个 serviceManager 去管理这些众多的接口请求。示例代码如下： 1234567891011121314151617181920212223public class ServiceManager &#123; private static ServiceManager instance = null; public synchronized static ServiceManager getInstance() &#123; return instance != null ? instance : new ServiceManager(); &#125; private OkHttpClient client = new OkHttpClient() .newBuilder() .addInterceptor(new HttpLoggingInterceptor() .setLevel(BuildConfig.DEBUG ? HttpLoggingInterceptor.Level.BODY : HttpLoggingInterceptor.Level.NONE)) .build(); private Retrofit retrofit = new Retrofit.Builder() .baseUrl(StrUtil.BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); private IMovieTop250 iMovieTop250 = retrofit.create(IMovieTop250.class); public IMovieTop250 getiMovieTop250() &#123; return iMovieTop250; &#125;&#125; 简单的说明一下： 首先创建了一个 serviceManager 的单例。然后配置好 OkHttpClient 以及 Retrofit ，相关的注释比较清晰看一下就能明白。 当我们创建好 Retrofit 以后，就可以创建接口服务了使用 retrofit.create(IMovieTop250.class) 创建你的服务。最后向引用类提供一个方法 getiMovieTop250() 来实现请求即可。 至此，所有的请求工作都完成了。下面我们看一下去使用这些服务。 四 使用服务首先看一下代码示例： 12345678910111213141516171819202122232425262728293031323334353637// get movie from apiprivate void getMovie(int start, int count) &#123; ServiceManager.getInstance() .getiMovieTop250() .getMovie(start, count) .flatMap(new Func1&lt;JsonResult&lt;List&lt;Subject&gt;&gt;, Observable&lt;Subject&gt;&gt;() &#123; @Override public Observable&lt;Subject&gt; call(JsonResult&lt;List&lt;Subject&gt;&gt; listJsonResult) &#123; return Observable.from(listJsonResult.getSubjects()); &#125; &#125;) .toList() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Subject&gt;&gt;() &#123; @Override public void onNext(List&lt;Subject&gt; subjects) &#123; if (subjects != null) &#123; myAdapter.setDataList(subjects); &#125; &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; if (e instanceof java.net.ConnectException) &#123; Toast.makeText(MainActivity.this, \"当前网络不可用\",Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;);&#125; 调用很简单直接通过 serviceManager 就能使用服务了 123ServiceManager.getInstance() .getiMovieTop250() .getMovie(start, count) 剩下的代码需要去看一下我的关于 Rxjava 介绍的文章 《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》。","raw":"---\ntitle: Retrofit + Rxjava 从入门到跑路（Retrofit介绍）\ndate: 2016-12-29 14:53:19\ntags: Android\ncategories: Android\n---\n\n### Retrofit是什么\n\n简单的一句话是一个网络库用来处理一些网络上的数据传输。\n\n> Type-safe HTTP client for Android and Java by Square, Inc.\n>\n> 适用于Android 和 Java 的类型安全的Http 客户端\n\n<br>\n\n### 如何使用Retrofit\n\n#### 一\t配置 Retrofit\n\n使用 Gradle 方式添加依赖：\n\n```java\n    // rxAndroid\n    compile 'io.reactivex:rxandroid:1.0.1'\n    // retrofit2\n    compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'\n    compile 'com.squareup.retrofit2:retrofit:2.0.2'\n    compile 'com.squareup.retrofit2:converter-gson:2.0.2'\n    // network interceptor\n    compile 'com.squareup.okhttp3:logging-interceptor:3.1.2'\n```\n\n> 注意 converter-gson 是一个转换器，你还可以在以下转换器中选择（本文使用Gson作为例子）：\n\n- [Gson](https://github.com/google/gson): `com.squareup.retrofit2:converter-gson` （google 官方推荐）\n- [Jackson](http://wiki.fasterxml.com/JacksonHome): `com.squareup.retrofit2:converter-jackson`\n- [Moshi](https://github.com/square/moshi/): `com.squareup.retrofit2:converter-moshi`\n- [Protobuf](https://developers.google.com/protocol-buffers/): `com.squareup.retrofit2:converter-protobuf`\n- [Wire](https://github.com/square/wire): `com.squareup.retrofit2:converter-wire`\n- [Simple XML](http://simple.sourceforge.net/): `com.squareup.retrofit2:converter-simplexml`\n- Scalars (primitives, boxed, and String): `com.squareup.retrofit2:converter-scalars`\n\n> 我们还可以在 gradle 中添加 网络拦截器，方便调试。\n>\n> 添加网络调试：`compile 'com.squareup.okhttp3:logging-interceptor:3.1.2'`\n>\n> 同时如果要使用 rxjava  rxAndroid 与 retrofit 搭配使用，需要添加以下依赖\n>\n> `compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'`\n>\n> `compile 'io.reactivex:rxandroid:1.0.1'`\n\n\n\n#### 二  创建服务\n\n当你完成了 retrofit 的配置之后，就可以开始创建服务请求了。retrofit 通过接口的方式来提供网络上的请求，下面通过简单的例子来看看如何创建服务。\n\n```java\npublic interface IMovieTop250 {\n    @GET(\"v2/movie/top250?\")\n    Observable<JsonResult<List<Subject>>> getMovie(@Query(\"start\") int start,\n                                                   @Query(\"count\") int count);\n}\n```\n\n这里接上一篇[《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》](https://jngoogle.github.io/2016/12/26/Retrofit-RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Rxjava%E4%BB%8B%E7%BB%8D%EF%BC%89/) 中的json结果，使用的是豆瓣电影的API [Top250 ](https://developers.douban.com/wiki/?title=movie_v2#top250) 的API，Url 请求长这样：` https://api.douban.com/v2/movie/top250?start=0;count=1`\n\n\n\n1 **填写请求地址**\n\n我们这样来分解，把 `https://api.douban.com/` 作为base_url ，剩下的 `v2/movie/top250?` 作为这个接口请求的url。前面放上 GET 关键字表示请求的方式。base_url 我们将在 serviceManager 中去处理，后面会提到。\n\n> 特别提示：base_url 需要以斜杠 / 结尾，否则会报错\n\n\n\n2 **确定返回类型**\n\n写好了请求的地址，我们来写请求返回的参数类型 ` Observable<JsonResult<List<Subject>>>` 表示从 API 返回一个 JsonResult 类型，并且这里使用了 rxjava ，所以是 Observable 而并不是 Call 。\n\n\n\n3  **填写请求参数**（如果需要）\n\n这里我们需要两个参数，采用 Query 关键字，键值对中键的名称分别为 start  和  count 写在括号中，后面写上对应的变量名。\n\n> 关于请求的关键字如 GET POST 可以去 [这里](http://square.github.io/retrofit/) 查看\n\n\n这里我们看到一个请求地址就对应着一个接口，当然你可以在一个接口中创建多个请求方法（一般用在同一类型的请求但是各个请求的参数有区别的情况）。这里举一个例子：\n\n```java\npublic interface ISubmitService {\n    @POST(\"confirmOrder?\")\n    Observable<SubmitEntity> submitSaleOrder(@Query(\"id\") int id,\n                                             @Query(\"task_id\") int taskId);\n\n    @POST(\"confirmOrder?\")\n    Observable<SubmitEntity> submitRepairOrder(@Query(\"id\") int id,\n                                               @Query(\"task_id\") int taskId,\n                                               @Query(\"order_id\") int orderId,\n                                               @Query(\"order_type\") String orderType);\n}\n```\n\n这个请求接口中两个请求方法只是请求的参数不同而已。完成了以上步骤就创建好了 接口形式的网络请求了。\n\n\n\n#### 三  配置你的 ServiceManager\n\n当你完成了请求接口的创建之后，我们会使用一个 serviceManager 去管理这些众多的接口请求。示例代码如下：\n\n```java\npublic class ServiceManager {\n    private static ServiceManager instance = null;\n    public synchronized static ServiceManager getInstance() {\n        return instance != null ? instance : new ServiceManager();\n    }\n    private OkHttpClient client = new OkHttpClient()\n            .newBuilder()\n            .addInterceptor(new HttpLoggingInterceptor()\n                    .setLevel(BuildConfig.DEBUG ?\n                            HttpLoggingInterceptor.Level.BODY : HttpLoggingInterceptor.Level.NONE))\n            .build();\n    private Retrofit retrofit = new Retrofit.Builder()\n            .baseUrl(StrUtil.BASE_URL)\n            .client(client)\n            .addConverterFactory(GsonConverterFactory.create())\n            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n            .build();\n    \n     private IMovieTop250 iMovieTop250 = retrofit.create(IMovieTop250.class);\n     public IMovieTop250 getiMovieTop250() {\n        return iMovieTop250;\n    }\n}\n```\n\n\n\n简单的说明一下：\n\n首先创建了一个 serviceManager 的单例。然后配置好 OkHttpClient  以及 Retrofit ，相关的注释比较清晰看一下就能明白。\n\n当我们创建好 Retrofit 以后，就可以创建接口服务了使用  `retrofit.create(IMovieTop250.class)` 创建你的服务。最后向引用类提供一个方法  `getiMovieTop250()`  来实现请求即可。\n\n至此，所有的请求工作都完成了。下面我们看一下去使用这些服务。\n\n\n\n#### 四  使用服务\n\n首先看一下代码示例：\n\n```java\n    // get movie from api\n    private void getMovie(int start, int count) {\n        ServiceManager.getInstance()\n                .getiMovieTop250()\n                .getMovie(start, count)\n                .flatMap(new Func1<JsonResult<List<Subject>>, Observable<Subject>>() {\n                    @Override\n                    public Observable<Subject> call(JsonResult<List<Subject>> listJsonResult) {\n                        return Observable.from(listJsonResult.getSubjects());\n                    }\n                })\n                .toList()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<List<Subject>>() {\n                    @Override\n                    public void onNext(List<Subject> subjects) {\n                        if (subjects != null) {\n                            myAdapter.setDataList(subjects);\n                        }\n                    }\n\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                        if (e instanceof java.net.ConnectException) {\n                            Toast.makeText(MainActivity.this, \"当前网络不可用\",Toast.LENGTH_SHORT).show();\n                        }\n                    }\n                });\n\n    }\n```\n\n调用很简单直接通过 serviceManager 就能使用服务了\n\n```java\n  ServiceManager.getInstance()\n                .getiMovieTop250()\n                .getMovie(start, count)\n```\n\n剩下的代码需要去看一下我的关于 Rxjava 介绍的文章 [《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》](https://jngoogle.github.io/2016/12/26/Retrofit-RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Rxjava%E4%BB%8B%E7%BB%8D%EF%BC%89/)。","content":"<h3 id=\"Retrofit是什么\"><a href=\"#Retrofit是什么\" class=\"headerlink\" title=\"Retrofit是什么\"></a>Retrofit是什么</h3><p>简单的一句话是一个网络库用来处理一些网络上的数据传输。</p>\n<blockquote>\n<p>Type-safe HTTP client for Android and Java by Square, Inc.</p>\n<p>适用于Android 和 Java 的类型安全的Http 客户端</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"如何使用Retrofit\"><a href=\"#如何使用Retrofit\" class=\"headerlink\" title=\"如何使用Retrofit\"></a>如何使用Retrofit</h3><h4 id=\"一-配置-Retrofit\"><a href=\"#一-配置-Retrofit\" class=\"headerlink\" title=\"一    配置 Retrofit\"></a>一    配置 Retrofit</h4><p>使用 Gradle 方式添加依赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// rxAndroid</span></div><div class=\"line\">compile <span class=\"string\">'io.reactivex:rxandroid:1.0.1'</span></div><div class=\"line\"><span class=\"comment\">// retrofit2</span></div><div class=\"line\">compile <span class=\"string\">'com.squareup.retrofit2:adapter-rxjava:2.0.2'</span></div><div class=\"line\">compile <span class=\"string\">'com.squareup.retrofit2:retrofit:2.0.2'</span></div><div class=\"line\">compile <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.0.2'</span></div><div class=\"line\"><span class=\"comment\">// network interceptor</span></div><div class=\"line\">compile <span class=\"string\">'com.squareup.okhttp3:logging-interceptor:3.1.2'</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意 converter-gson 是一个转换器，你还可以在以下转换器中选择（本文使用Gson作为例子）：</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/google/gson\" target=\"_blank\" rel=\"external\">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code> （google 官方推荐）</li>\n<li><a href=\"http://wiki.fasterxml.com/JacksonHome\" target=\"_blank\" rel=\"external\">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li>\n<li><a href=\"https://github.com/square/moshi/\" target=\"_blank\" rel=\"external\">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li>\n<li><a href=\"https://developers.google.com/protocol-buffers/\" target=\"_blank\" rel=\"external\">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li>\n<li><a href=\"https://github.com/square/wire\" target=\"_blank\" rel=\"external\">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li>\n<li><a href=\"http://simple.sourceforge.net/\" target=\"_blank\" rel=\"external\">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li>\n<li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li>\n</ul>\n<blockquote>\n<p>我们还可以在 gradle 中添加 网络拦截器，方便调试。</p>\n<p>添加网络调试：<code>compile &#39;com.squareup.okhttp3:logging-interceptor:3.1.2&#39;</code></p>\n<p>同时如果要使用 rxjava  rxAndroid 与 retrofit 搭配使用，需要添加以下依赖</p>\n<p><code>compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;</code></p>\n<p><code>compile &#39;io.reactivex:rxandroid:1.0.1&#39;</code></p>\n</blockquote>\n<h4 id=\"二-创建服务\"><a href=\"#二-创建服务\" class=\"headerlink\" title=\"二  创建服务\"></a>二  创建服务</h4><p>当你完成了 retrofit 的配置之后，就可以开始创建服务请求了。retrofit 通过接口的方式来提供网络上的请求，下面通过简单的例子来看看如何创建服务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IMovieTop250</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"v2/movie/top250?\"</span>)</div><div class=\"line\">    Observable&lt;JsonResult&lt;List&lt;Subject&gt;&gt;&gt; getMovie(<span class=\"meta\">@Query</span>(<span class=\"string\">\"start\"</span>) <span class=\"keyword\">int</span> start,</div><div class=\"line\">                                                   <span class=\"meta\">@Query</span>(<span class=\"string\">\"count\"</span>) <span class=\"keyword\">int</span> count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里接上一篇<a href=\"https://jngoogle.github.io/2016/12/26/Retrofit-RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Rxjava%E4%BB%8B%E7%BB%8D%EF%BC%89/\">《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》</a> 中的json结果，使用的是豆瓣电影的API <a href=\"https://developers.douban.com/wiki/?title=movie_v2#top250\" target=\"_blank\" rel=\"external\">Top250 </a> 的API，Url 请求长这样：<code>https://api.douban.com/v2/movie/top250?start=0;count=1</code></p>\n<p>1 <strong>填写请求地址</strong></p>\n<p>我们这样来分解，把 <code>https://api.douban.com/</code> 作为base_url ，剩下的 <code>v2/movie/top250?</code> 作为这个接口请求的url。前面放上 GET 关键字表示请求的方式。base_url 我们将在 serviceManager 中去处理，后面会提到。</p>\n<blockquote>\n<p>特别提示：base_url 需要以斜杠 / 结尾，否则会报错</p>\n</blockquote>\n<p>2 <strong>确定返回类型</strong></p>\n<p>写好了请求的地址，我们来写请求返回的参数类型 <code>Observable&lt;JsonResult&lt;List&lt;Subject&gt;&gt;&gt;</code> 表示从 API 返回一个 JsonResult 类型，并且这里使用了 rxjava ，所以是 Observable 而并不是 Call 。</p>\n<p>3  <strong>填写请求参数</strong>（如果需要）</p>\n<p>这里我们需要两个参数，采用 Query 关键字，键值对中键的名称分别为 start  和  count 写在括号中，后面写上对应的变量名。</p>\n<blockquote>\n<p>关于请求的关键字如 GET POST 可以去 <a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">这里</a> 查看</p>\n</blockquote>\n<p>这里我们看到一个请求地址就对应着一个接口，当然你可以在一个接口中创建多个请求方法（一般用在同一类型的请求但是各个请求的参数有区别的情况）。这里举一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISubmitService</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@POST</span>(<span class=\"string\">\"confirmOrder?\"</span>)</div><div class=\"line\">    <span class=\"function\">Observable&lt;SubmitEntity&gt; <span class=\"title\">submitSaleOrder</span><span class=\"params\">(@Query(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id,</span></div><div class=\"line\">                                             @<span class=\"title\">Query</span><span class=\"params\">(<span class=\"string\">\"task_id\"</span>)</span> <span class=\"keyword\">int</span> taskId);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@POST</span>(<span class=\"string\">\"confirmOrder?\"</span>)</div><div class=\"line\">    <span class=\"function\">Observable&lt;SubmitEntity&gt; <span class=\"title\">submitRepairOrder</span><span class=\"params\">(@Query(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id,</span></div><div class=\"line\">                                               @<span class=\"title\">Query</span><span class=\"params\">(<span class=\"string\">\"task_id\"</span>)</span> <span class=\"keyword\">int</span> taskId,</div><div class=\"line\">                                               @<span class=\"title\">Query</span><span class=\"params\">(<span class=\"string\">\"order_id\"</span>)</span> <span class=\"keyword\">int</span> orderId,</div><div class=\"line\">                                               @<span class=\"title\">Query</span><span class=\"params\">(<span class=\"string\">\"order_type\"</span>)</span> String orderType);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个请求接口中两个请求方法只是请求的参数不同而已。完成了以上步骤就创建好了 接口形式的网络请求了。</p>\n<h4 id=\"三-配置你的-ServiceManager\"><a href=\"#三-配置你的-ServiceManager\" class=\"headerlink\" title=\"三  配置你的 ServiceManager\"></a>三  配置你的 ServiceManager</h4><p>当你完成了请求接口的创建之后，我们会使用一个 serviceManager 去管理这些众多的接口请求。示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceManager instance = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> ServiceManager <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance != <span class=\"keyword\">null</span> ? instance : <span class=\"keyword\">new</span> ServiceManager();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">private</span> OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient()</div><div class=\"line\">            .newBuilder()</div><div class=\"line\">            .addInterceptor(<span class=\"keyword\">new</span> HttpLoggingInterceptor()</div><div class=\"line\">                    .setLevel(BuildConfig.DEBUG ?</div><div class=\"line\">                            HttpLoggingInterceptor.Level.BODY : HttpLoggingInterceptor.Level.NONE))</div><div class=\"line\">            .build();</div><div class=\"line\">    <span class=\"keyword\">private</span> Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</div><div class=\"line\">            .baseUrl(StrUtil.BASE_URL)</div><div class=\"line\">            .client(client)</div><div class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class=\"line\">            .build();</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"keyword\">private</span> IMovieTop250 iMovieTop250 = retrofit.create(IMovieTop250.class);</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> IMovieTop250 <span class=\"title\">getiMovieTop250</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> iMovieTop250;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单的说明一下：</p>\n<p>首先创建了一个 serviceManager 的单例。然后配置好 OkHttpClient  以及 Retrofit ，相关的注释比较清晰看一下就能明白。</p>\n<p>当我们创建好 Retrofit 以后，就可以创建接口服务了使用  <code>retrofit.create(IMovieTop250.class)</code> 创建你的服务。最后向引用类提供一个方法  <code>getiMovieTop250()</code>  来实现请求即可。</p>\n<p>至此，所有的请求工作都完成了。下面我们看一下去使用这些服务。</p>\n<h4 id=\"四-使用服务\"><a href=\"#四-使用服务\" class=\"headerlink\" title=\"四  使用服务\"></a>四  使用服务</h4><p>首先看一下代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// get movie from api</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">getMovie</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> count)</span> </span>&#123;</div><div class=\"line\">    ServiceManager.getInstance()</div><div class=\"line\">            .getiMovieTop250()</div><div class=\"line\">            .getMovie(start, count)</div><div class=\"line\">            .flatMap(<span class=\"keyword\">new</span> Func1&lt;JsonResult&lt;List&lt;Subject&gt;&gt;, Observable&lt;Subject&gt;&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Subject&gt; <span class=\"title\">call</span><span class=\"params\">(JsonResult&lt;List&lt;Subject&gt;&gt; listJsonResult)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> Observable.from(listJsonResult.getSubjects());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .toList()</div><div class=\"line\">            .subscribeOn(Schedulers.io())</div><div class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">            .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;List&lt;Subject&gt;&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;Subject&gt; subjects)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (subjects != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        myAdapter.setDataList(subjects);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> java.net.ConnectException) &#123;</div><div class=\"line\">                        Toast.makeText(MainActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"当前网络不可用\"</span>,Toast.LENGTH_SHORT).show();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用很简单直接通过 serviceManager 就能使用服务了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServiceManager.getInstance()</div><div class=\"line\">              .getiMovieTop250()</div><div class=\"line\">              .getMovie(start, count)</div></pre></td></tr></table></figure>\n<p>剩下的代码需要去看一下我的关于 Rxjava 介绍的文章 <a href=\"https://jngoogle.github.io/2016/12/26/Retrofit-RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Rxjava%E4%BB%8B%E7%BB%8D%EF%BC%89/\">《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》</a>。</p>\n","slug":"Retrofit-Rxjava-从入门到跑路（Retrofit）","updated":"2017-09-03T13:21:37.606Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2016/12/29/Retrofit-Rxjava-从入门到跑路（Retrofit）/","excerpt":"","categories":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/tags/Android/"}]},{"title":"Retrofit + RxJava 从入门到跑路（Rxjava介绍）","date":"2016-12-26T06:15:46.000Z","path":"2016/12/26/Retrofit-RxJava-从入门到跑路（Rxjava介绍）/","text":"本文较长建议在电脑上阅读(文中除 RxJava + Retrofit 结合运用部分，其余代码示例来自 扔物线 博客) 2016年也差不多要结束了，作为一个Android小白今年学到的东西回头来看发现还是太少了。给我印象最深的是 MVP设计模式、Retrofit以及RxJava。这篇文章就来讲一下Retrofit和RxJava。 网上有很多这两者相关的资料但是结合起来的文章比较少，本着我们学习的目的是为了真正在工作项目中使用，所以决定写下这篇文章，本人由于工作经验较少文中出现错误了希望大家指出纠正。 这里我要先分开讲两者然后再结合起来，只有分开弄清楚了才能在结合的时候运用自如。 ​RxJava首先强烈推荐 扔物线 大大的这篇文章 《给 Android 开发者的 RxJava 详解》 毫不夸张的说，如果真正吃透了这篇文章肯定是能够理解并使用RxJava了（这篇文章较长，系统的介绍了RxJava）。 本人也是看了许多RxJava的文章最终发现了这篇文章才对RxJava形成了一个相对清楚的认识和理解。这里我就用我自己的理解在来梳理一下RxJava。 为什么要用Rxjava，以及什么场景下使用 a library for composing asynchronous and event-based programs by using observable sequences.— from Rxjava github 通过使用可观察序列来组成异步和基于事件的程序的库。 异步 + 简洁 是Rxjava的关键词 。 在需要处理异步的场景下使用：Rxjava的本质还是为了处理异步这件事。 因为Rxjava处理逻辑的十分简洁 ，采用了链式的组织方式使得方便拼接来处理复杂的逻辑。 介绍观察者模式因为Rxjava在处理异步问题的时候采用的是 观察者模式。我们首先来熟悉一下观察者模式。其实对于Android日常开发中我们已经非常熟练的去使用了观察者模式了。我们都使用过Button，写过Button的点击事件。 名词解释（熟悉自行跳过直接看 代码实现 ） 所谓的 观察者模式 也可以称为 注册-订阅模式，就拿当下十分流行的直播来类比一下。比如我很喜欢B站的一位阿婆主（咦，好像暴露了什么）。她的每次直播我都想看，假设阿婆主直播的时间不是固定的，那我很有可能错过直播那我应该怎么做才能解决这个问题呢？ 两种方式： 阿婆主每次直播的时候自己主动通知我（我觉得只有可能我在阿婆主的粉丝群里或者就我一个观众 233才可能这样） 我在B站上关注了阿婆主。注意噢，这里的关注就是意味着订阅了，也就是说只要阿婆主有直播我就能收到通知。 至此我想你应该懂了什么叫 注册-订阅（观察者）模式了，就是说只要我订阅了某个事件源（阿婆主开直播），当事件发生时我就能收到通知。好，我们接下来用一张表来更加清晰的看看这个模式的各个部分组成。 观察者（事件处理者） 被观察者（搞事者） 订阅 我 阿婆主 关注阿婆主这个动作 现在的直播都是采用观察者模式的，好处就是在于无论阿婆主有多少粉丝只要你关注（订阅）了阿婆主，当阿婆主开直播了，这个事件消息能够发送给所有订阅了的粉丝。也就是不需要阿婆主每一个人去挨个通知了。 我们现在再回到开头的提到的Button的这个事情。我们换一种说法可以把观察者模式理解成为监听模式。关注阿婆主之后就好像放置了一个监听器一直在监听阿婆主是否开播这个事件。一旦阿婆主开播事件被触发监听器就启动，然后执行相应的处理（观看直播 or 给阿婆主刷刷礼物）。 所以看到这里写Android的小伙伴是不是觉得监听器有点熟悉，这个在Button上监听它被点击了的监听器不就是OnClickListener吗？当Button（被观察者 or 事件源）被点击之后，OnClickListener（观察者 or 事件处理者）就开始执行相应的操作，可能是跳转Activity也可能是弹出dialog等等。那这个监听器是在哪里订阅或者说关注了Button的一举一动的呢？当然就是在你经常写的 btn.setOnClickListener()的时候啦。在这个时候Button已经被OnClickListener所关注了。 Observer 观察者（事件处理者） Observable 被观察者（搞事者） Subscribe 订阅 我 阿婆主 关注阿婆主这个动作 OnClickListener 监听器 Button 按钮 setOnClickListener 绑定监听 好的，啰嗦了这么多我为什么要介绍这个观察者模式呢？ 是因为我们Rxjava就是要处理异步问题的，异步一般来说那个不在主线程中的任务会比较耗时，为了防止ANR就会用到观察者模式。观察者不用时时刻刻去查看是否需要更新View了（如果那样好累的说）只要我关注了我需要关注的事件源（比如Button的点击事件）就可以在发生了特定事件的时候获得消息然后再更新View。 代码实现. 0 如何引入Rxjava Example for Gradle: 12345// in your modules' build.gradle // Rxjava compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2' // RXandroid compile 'io.reactivex:rxandroid:1.0.1' 1 创建观察者（事件处理者）Observer观察者决定了当事件被触发了做出怎样的回应（在onNext 方法中处理）。 123456789101112131415Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; ​ 首先说明我们在实际的开发中一般创建观察者的时候使用的并不是Observer而是Subscriber。Observer正如其字面的意思就是观察者，是一个接口里面的接口方法就是上面的三个方法，onNext() onCompleted() onError() 。而在实际开发中使用到的Subscriber是什么呢？通过查看源码 public abstract class Subscriber implements Observer, Subscription ，原来Subscriber是一个抽象类它实现了 Observer 和 Sbuscription 这两个接口。 Observer — onNext() onCompleted() onError() subscription — unsubscribe() isUnsubscribed() 其实Subscriber的用法跟Observer用法基本一致，相比于Observer多了一些重写方法,从表格中可以看出多了unsubscribe() 和 isUnsubscribed() 这两个方法。 新增的这两个接口方法有着重要的意义，unsubscribe() 用于取消订阅。恩，既然我可以关注一个阿婆主当然也能够取消关注嘛。这个方法一般是在 onStop() 或者 onPause() 中去实现，取消订阅释放内存防止内存泄漏。阿婆主我取消对你关注了你不可能还死皮赖脸的缠着不放吧 233 。 下面是 subscribe的创建（其实基本都是一样的）。 123456789101112131415161718Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 2 创建被观察者（搞事者）Observable Observable决定了发送什么事件以及何时发送时间即 what &amp; when。 12345678Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"World\"); subscriber.onCompleted(); &#125;&#125;); 我们从上面的简单例子可以看到不管是观察者还是被观察者处理的数据类型都是基本的String类型。在真实的项目开发中，我们在使用Rxjava + Retrofit 的时候要处理的类型往往是通过服务器给定的，通常事先是不知道的。这就需要我们在类型的地方使用泛型来处理，这里只是简单的示例。 除了可以使用 create来创建一个被观察者还可以使用just 和 from， 而这些都被称作操作符，大家可以去这里 了解一下。 3 订阅Subscribe 只要在 Observable中订阅一下，将Observe与其连接起来就是完成订阅了。 举例说明一下： 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： 123456789101112131415161718192021222324int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 好，至此我们已经看到了整个观察者模式一个完整的流程了即创建 Observable 和 Observe 然后通过 Subscribe 连接两者即可。 真正的使用Rxjava在上面一节 介绍观察者模式中我们提出来完整的流程，我们也就基本的了解了Rxjava的工作流程，但是这不是Rxjava真正的使用方式！ 因为我们使用Rxjava的最初目的还是处理 异步问题。而目前为止所看到的所有代码都是在同一个线程中执行的，所以并不是Rxjava真正的使用方式。接下来，我们就要在不同的线程之间去使用Rxjava。 为了在不同的线程中去使用Rxjava这就表明我们需要线程切换。我在A线程做一件事情，然后切换到B线程去做另外一件事情。刚好Rxjava提供了调度器，它可以用来切换线程。在Rxjava中使用Schedulars — 调度器来切换线程。该调度器已经默认提供了一些线程可供我们使用。 方法名 描述 immediate() 在当前线程中执行(缺省模式) computation() 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 io() I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程 newThread() 总是创建新的线程，并在新的线程中执行 mainThread() Android中的主线程 一般在实际的项目中用到最多的就是 io newThread 以及 mainThread 这三个线程。在被观察者中 Observable提供了 两个方式分别是 subscribeOn() 和 observeOn() 来指定观察者和被观察者分别运行在哪个线程。 举例说明： 1234567891011ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;ApiResult&lt;Subject&gt;&gt;(context) &#123; @Override public void onNext(ApiResult&lt;Subject&gt; subjectApiResult) &#123; // do something &#125; &#125;); 从这个例子上我们可以看到 观察者是运行在新的线程上而 被观察者则是运行在主线程上。注意看在subscribeOn() 的前一句是获取电影的相关信息 getMovie()， 而获取这个信息需要的时间可能较长且不确定所以放在了另外一个新的线程中去执行你可以说实在后台线程执行。最后得到数据之后在再主线程中进行相应的处理。（这里已经是使用了Rxjava + Retrofit） Rxjava是如此的灵活如果你能看到这里非常感谢，以上的内容都是介绍和解释了Rxjava 是如何处理异步问题。还记得文章最开头提到的Rxjava的两个关键词吗？ 异步 + 简洁， 这一节就要介绍Rxjava为什么相比于其他处理异步问题的方式为什么简洁、灵活。 我们先来说说什么样的逻辑是容易被理解的。我个人认为直的逻辑，换句话说不需要考虑各种分支各种例外情况或者是多层关系的逻辑是容易被理解的（层级、依赖、分支较少的逻辑我认为就是直的逻辑）。好比路线，一条直路就能到达目的地当时给人的感觉是清晰、简单的。恰好，Rxjava就是这种链式的一条直的逻辑。依靠着众多 操作符 能够非常方便的实现拼积木的感觉（多了直接扔掉，少了直接加上就好不用考虑依赖、层级之间的关系）。 举例演示一下（注意这里Rxjava和Retrofit结合在使用） 1234567891011121314151617181920212223ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .flatMap(new Func1&lt;ApiResult&lt;Subject&gt;, Observable&lt;Subject&gt;&gt;() &#123; @Override public Observable&lt;Subject&gt; call(ApiResult&lt;Subject&gt; subjectApiResult) &#123; return Observable.from(subjectApiResult.getSubjects()); &#125; &#125;) .map(new Func1&lt;Subject, String&gt;() &#123; @Override public String call(Subject subject) &#123; return subject.getTitle(); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;String&gt;(context) &#123; @Override public void onNext(String s) &#123; apiResultTv.setText(s); &#125; &#125;); ok,对于刚刚接触Rxjava的人可能一下子会觉得真正使用Rxjava是这么的麻烦，看着代码好像很多逻辑反而不清晰呢。其实这只是由于新接触Rxjava被表面的代码书写格式所吓到了而已。下面来分析一下这一串代码，首先介绍一下背景： 我通过豆瓣电影API得到电影Top250 的相关信息，然后在手机上显示出来更新UI。 豆瓣电影API可以在 这里查看 ，此处代码使用的是 榜单 Top250 这个接口(json返回结果较复杂请耐心分析)。在chrome浏览器中下载 postman 然后输入 https://api.douban.com/v2/movie/top250?start=0&amp;count=10 查看json返回结果。 我们来分析代码，首先通过getMovie() 得到了API所返回的json结果。这里根据提供的json结果返回的格式是 Observable &lt; ApiResult&lt; Subject&gt;&gt; 是一个被观察者Observable （这里真实的场景就是我们通过网络就得到了被观察者而不是自己去创建），然后我们开始多次使用操作符来对这个最原始的 json返回结果进行剥离只留下我们需要的数据，比如这里我只需要榜单中电影的名字。 第一次我们使用了 flatmap 得到了subject ， 然后我们再使用了 map 得到了String 这个对应着电影的名字。此时被观察者所发出的事件中的数据由 Observable &lt; ApiResult&lt; Subject&gt;&gt; 变成了 String 。至此被观察者的事情就处理好了事件源返回了我们想要的那一部分的数据。接下来分别使用 subscribeOn 和 observeOn 来分别指定这些任务应该运行在哪个线程。显然我们指定了观察者的任务处理在 io 线程， 被观察者是运行在主线程中的。最后的最后，我们进行了关注 - 订阅 告诉观察者如果你收到了被观察者的事件通知应该做点什么（setText 更新了UI）。 好，如果你再结合上lambda 表达式的话，代码会看起来更清爽（但是个人不推荐）。 12345678910111213ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .flatMap(subjectApiResult -&gt; Observable.from(subjectApiResult.getSubjects())) .map(subject -&gt; subject.getTitle()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;String&gt;(context) &#123; @Override public void onNext(String s) &#123; apiResultTv.setText(s); &#125; &#125;); 总结一下：其实整个这一串代码就是链式下来的一个直的逻辑。 得到API返回结果 getMovie() 转化得到的结果为Subject flatMap() 转化得到的结果为String map() 指定线程 observeOn() subscribeOn() 订阅 subscribe() Rxjava 之所以说它灵活是因为在转化的过程中你想怎么转化都是可以的，它可以通过多种操作符来适应你的各种筛选要求。之后会用一篇文章介绍一下常用的一些操作符。 ​后记终于告一段落了，Rxjava 的基本介绍就这么多了，希望这边文章能给你们一点点帮助。本文中除了 Rxjava 与 Retrofit结合的代码是原创，剩下的示例代码来自 扔物线。还有如果想了解一下 lambda 表达式的同学可以去 这里学习 特别感谢 饭窝 扔物线 ​","raw":"---\ntitle: Retrofit + RxJava 从入门到跑路（Rxjava介绍）\ndate: 2016-12-26 14:15:46\ntags: Android\ncategories: Android\n---\n\n> 本文较长建议在电脑上阅读(文中除 RxJava + Retrofit 结合运用部分，其余代码示例来自 扔物线 博客)\n\n2016年也差不多要结束了，作为一个Android小白今年学到的东西回头来看发现还是太少了。给我印象最深的是 MVP设计模式、Retrofit以及RxJava。这篇文章就来讲一下Retrofit和RxJava。\n\n网上有很多这两者相关的资料但是结合起来的文章比较少，本着我们学习的目的是为了真正在工作项目中使用，所以决定写下这篇文章，本人由于工作经验较少文中出现错误了希望大家指出纠正。\n\n这里我要先分开讲两者然后再结合起来，只有分开弄清楚了才能在结合的时候运用自如。\n\n# ​RxJava\n\n首先强烈推荐 [扔物线](https://github.com/rengwuxian) 大大的这篇文章 [ 《给 Android 开发者的 RxJava 详解》](http://gank.io/post/560e15be2dca930e00da1083) 毫不夸张的说，如果真正吃透了这篇文章肯定是能够理解并使用RxJava了（这篇文章较长，系统的介绍了RxJava）。\n\n本人也是看了许多RxJava的文章最终发现了这篇文章才对RxJava形成了一个相对清楚的认识和理解。这里我就用我自己的理解在来梳理一下RxJava。\n\n### 为什么要用Rxjava，以及什么场景下使用\n\n> a library for composing asynchronous and event-based programs by using observable sequences.--- from Rxjava github\n>\n> 通过使用可观察序列来组成异步和基于事件的程序的库。\n\n异步 + 简洁  是Rxjava的关键词 。\n\n- 在需要处理异步的场景下使用：Rxjava的本质还是为了处理异步这件事。\n- 因为Rxjava处理逻辑的十分简洁 ，采用了链式的组织方式使得方便拼接来处理复杂的逻辑。\n\n\n\n### 介绍观察者模式\n\n因为Rxjava在处理异步问题的时候采用的是 观察者模式。我们首先来熟悉一下观察者模式。其实对于Android日常开发中我们已经非常熟练的去使用了观察者模式了。我们都使用过Button，写过Button的点击事件。\n\n- **名词解释**（熟悉自行跳过直接看 `代码实现` ）\n\n所谓的 观察者模式 也可以称为 注册-订阅模式，就拿当下十分流行的直播来类比一下。比如我很喜欢B站的一位阿婆主（咦，好像暴露了什么）。她的每次直播我都想看，假设阿婆主直播的时间不是固定的，那我很有可能错过直播那我应该怎么做才能解决这个问题呢？\n\n两种方式：\n\n1.  阿婆主每次直播的时候自己主动通知我（我觉得只有可能我在阿婆主的粉丝群里或者就我一个观众 233才可能这样）\n2.  我在B站上关注了阿婆主。注意噢，这里的关注就是意味着订阅了，也就是说只要阿婆主有直播我就能收到通知。\n\n至此我想你应该懂了什么叫 注册-订阅（观察者）模式了，就是说只要我订阅了某个事件源（阿婆主开直播），当事件发生时我就能收到通知。好，我们接下来用一张表来更加清晰的看看这个模式的各个部分组成。\n\n| 观察者（事件处理者） | 被观察者（搞事者） | 订阅        |\n| ---------- | :-------- | :-------- |\n| 我          | 阿婆主       | 关注阿婆主这个动作 |\n\n现在的直播都是采用观察者模式的，好处就是在于无论阿婆主有多少粉丝只要你关注（订阅）了阿婆主，当阿婆主开直播了，这个事件消息能够发送给所有订阅了的粉丝。也就是不需要阿婆主每一个人去挨个通知了。\n\n我们现在再回到开头的提到的Button的这个事情。我们换一种说法可以把观察者模式理解成为监听模式。关注阿婆主之后就好像放置了一个监听器一直在监听阿婆主是否开播这个事件。一旦阿婆主开播事件被触发监听器就启动，然后执行相应的处理（观看直播 or 给阿婆主刷刷礼物）。\n\n所以看到这里写Android的小伙伴是不是觉得监听器有点熟悉，这个在Button上监听它被点击了的监听器不就是OnClickListener吗？当Button（被观察者 or 事件源）被点击之后，OnClickListener（观察者 or 事件处理者）就开始执行相应的操作，可能是跳转Activity也可能是弹出dialog等等。那这个监听器是在哪里订阅或者说关注了Button的一举一动的呢？当然就是在你经常写的 `btn.setOnClickListener()`的时候啦。在这个时候Button已经被OnClickListener所关注了。\n\n| Observer  观察者（事件处理者）  | Observable  被观察者（搞事者） | Subscribe  订阅             |\n| :-------------------- | --------------------- | ------------------------- |\n| 我                     | 阿婆主                   | 关注阿婆主这个动作                 |\n| OnClickListener   监听器 | Button   按钮           | setOnClickListener   绑定监听 |\n\n好的，啰嗦了这么多我为什么要介绍这个观察者模式呢？ 是因为我们Rxjava就是要处理异步问题的，异步一般来说那个不在主线程中的任务会比较耗时，为了防止ANR就会用到观察者模式。观察者不用时时刻刻去查看是否需要更新View了（如果那样好累的说）只要我关注了我需要关注的事件源（比如Button的点击事件）就可以在发生了特定事件的时候获得消息然后再更新View。\n\n- **代码实现**.\n\n  **0 如何引入Rxjava**\n\n  Example for Gradle:\n\n  ```java\n  \t// in your modules' build.gradle\n      // Rxjava\n      compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'\n      // RXandroid\n      compile 'io.reactivex:rxandroid:1.0.1'\n  ```\n\n  **1 创建观察者（事件处理者）Observer**\n  观察者决定了当事件被触发了做出怎样的回应（在onNext 方法中处理）。  \n\n  ```java\n  Observer<String> observer = new Observer<String>() {\n      @Override\n      public void onNext(String s) {\n          Log.d(tag, \"Item: \" + s);\n      }\n   \n      @Override\n      public void onCompleted() {\n          Log.d(tag, \"Completed!\");\n      }\n   \n      @Override\n      public void onError(Throwable e) {\n          Log.d(tag, \"Error!\");\n      }};\n  ```\n\n  ​\n\n  首先说明我们在实际的开发中一般创建观察者的时候使用的并不是Observer而是Subscriber。\n  Observer正如其字面的意思就是观察者，是一个接口里面的接口方法就是上面的三个方法，onNext()  onCompleted()  onError() 。而在实际开发中使用到的Subscriber是什么呢？\n  通过查看源码 public abstract class Subscriber<T> implements Observer<T>, Subscription ，原来Subscriber是一个抽象类它实现了 Observer 和 Sbuscription 这两个接口。\n\n  - Observer  --- onNext()   onCompleted()  onError()\n  - subscription --- unsubscribe()  isUnsubscribed()\n\n其实Subscriber的用法跟Observer用法基本一致，相比于Observer多了一些重写方法,从表格中可以看出多了`unsubscribe()` 和 `isUnsubscribed()` 这两个方法。\n\n> 新增的这两个接口方法有着重要的意义，`unsubscribe()` 用于取消订阅。恩，既然我可以关注一个阿婆主当然也能够取消关注嘛。这个方法一般是在 onStop() 或者 onPause() 中去实现，取消订阅释放内存防止内存泄漏。阿婆主我取消对你关注了你不可能还死皮赖脸的缠着不放吧 233 。\n\n下面是 subscribe的创建（其实基本都是一样的）。\n\n```java\nSubscriber<String> subscriber = new Subscriber<String>() {\n    \n@Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n \n    \n@Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n \n    \n@Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }};\n```\n\n**2 创建被观察者（搞事者）Observable**\n\nObservable决定了发送什么事件以及何时发送时间即 what & when。\n\n```java\nObservable observable = Observable.create(new Observable.OnSubscribe<String>() {\n    \n@Override\n    public void call(Subscriber<? super String> subscriber) {\n        subscriber.onNext(\"Hello\");\n        subscriber.onNext(\"World\");\n        subscriber.onCompleted();\n    }});\n```\n\n我们从上面的简单例子可以看到不管是观察者还是被观察者处理的数据类型都是基本的String类型。在真实的项目开发中，我们在使用Rxjava + Retrofit 的时候要处理的类型往往是通过服务器给定的，通常事先是不知道的。这就需要我们在类型的地方使用泛型来处理，这里只是简单的示例。\n\n> 除了可以使用 create来创建一个被观察者还可以使用just 和 from， 而这些都被称作操作符，大家可以去[这里](https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html) 了解一下。\n\n**3 订阅Subscribe**\n\n只要在 Observable中订阅一下，将Observe与其连接起来就是完成订阅了。\n\n举例说明一下：\n\n由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：\n\n```java\nint drawableRes = ...;\nImageView imageView = ...;\nObservable.create(new OnSubscribe<Drawable>() {\n    @Override\n    public void call(Subscriber<? super Drawable> subscriber) {\n        Drawable drawable = getTheme().getDrawable(drawableRes));\n        subscriber.onNext(drawable);\n        subscriber.onCompleted();\n    }\n}).subscribe(new Observer<Drawable>() {\n    @Override\n    public void onNext(Drawable drawable) {\n        imageView.setImageDrawable(drawable);\n    }\n\n    @Override\n    public void onCompleted() {\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show();\n    }\n});\n```\n\n好，至此我们已经看到了整个观察者模式一个完整的流程了即创建 Observable 和 Observe 然后通过 Subscribe 连接两者即可。\n\n\n\n### 真正的使用Rxjava\n\n在上面一节 介绍观察者模式中我们提出来完整的流程，我们也就基本的了解了Rxjava的工作流程，但是这不是Rxjava真正的使用方式！\n\n因为我们使用Rxjava的最初目的还是处理 异步问题。而目前为止所看到的所有代码都是在同一个线程中执行的，所以并不是Rxjava真正的使用方式。接下来，我们就要在不同的线程之间去使用Rxjava。\n\n为了在不同的线程中去使用Rxjava这就表明我们需要线程切换。我在A线程做一件事情，然后切换到B线程去做另外一件事情。刚好Rxjava提供了调度器，它可以用来切换线程。在Rxjava中使用Schedulars --- 调度器来切换线程。该调度器已经默认提供了一些线程可供我们使用。\n\n| 方法名           | 描述                                       |\n| :------------ | :--------------------------------------- |\n| immediate()   | 在当前线程中执行(缺省模式)                           |\n| computation() | 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 |\n| io()          | I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程 |\n| newThread()   | 总是创建新的线程，并在新的线程中执行                       |\n| mainThread()  | Android中的主线程                             |\n\n一般在实际的项目中用到最多的就是 io  newThread 以及 mainThread 这三个线程。在被观察者中 Observable提供了 两个方式分别是 `subscribeOn()`  和 `observeOn()`  来指定观察者和被观察者分别运行在哪个线程。\n\n举例说明：\n\n```java\nServiceManager.getInstance()\n                        .getMovieService()\n                        .getMovie(0, 10)\n                        .subscribeOn(Schedulers.newThread())\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(new MySubscriber<ApiResult<Subject>>(context) {\n                            @Override\n                            public void onNext(ApiResult<Subject> subjectApiResult) {\n                                // do something\n                            }\n                        });\n```\n\n从这个例子上我们可以看到  观察者是运行在新的线程上而  被观察者则是运行在主线程上。注意看在subscribeOn() 的前一句是获取电影的相关信息  getMovie()， 而获取这个信息需要的时间可能较长且不确定所以放在了另外一个新的线程中去执行你可以说实在后台线程执行。最后得到数据之后在再主线程中进行相应的处理。（这里已经是使用了Rxjava + Retrofit）\n\n### Rxjava是如此的灵活\n\n如果你能看到这里非常感谢，以上的内容都是介绍和解释了Rxjava 是如何处理异步问题。还记得文章最开头提到的Rxjava的两个关键词吗？ 异步 +  简洁， 这一节就要介绍Rxjava为什么相比于其他处理异步问题的方式为什么简洁、灵活。\n\n我们先来说说什么样的逻辑是容易被理解的。我个人认为直的逻辑，换句话说不需要考虑各种分支各种例外情况或者是多层关系的逻辑是容易被理解的（层级、依赖、分支较少的逻辑我认为就是直的逻辑）。好比路线，一条直路就能到达目的地当时给人的感觉是清晰、简单的。恰好，Rxjava就是这种链式的一条直的逻辑。依靠着众多 操作符 能够非常方便的实现拼积木的感觉（多了直接扔掉，少了直接加上就好不用考虑依赖、层级之间的关系）。\n\n举例演示一下（注意这里Rxjava和Retrofit结合在使用）\n\n```java\nServiceManager.getInstance()\n                        .getMovieService()\n                        .getMovie(0, 10)\n                        .flatMap(new Func1<ApiResult<Subject>, Observable<Subject>>() {\n                            @Override\n                            public Observable<Subject> call(ApiResult<Subject> subjectApiResult) {\n                                return Observable.from(subjectApiResult.getSubjects());\n                            }\n                        })\n                        .map(new Func1<Subject, String>() {\n                            @Override\n                            public String call(Subject subject) {\n                                return subject.getTitle();\n                            }\n                        })\n                        .subscribeOn(Schedulers.io())\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(new MySubscriber<String>(context) {\n                            @Override\n                            public void onNext(String s) {\n                                apiResultTv.setText(s);\n                            }\n                        });\n```\n\nok,对于刚刚接触Rxjava的人可能一下子会觉得真正使用Rxjava是这么的麻烦，看着代码好像很多逻辑反而不清晰呢。其实这只是由于新接触Rxjava被表面的代码书写格式所吓到了而已。下面来分析一下这一串代码，首先介绍一下背景：\n\n我通过豆瓣电影API得到电影Top250 的相关信息，然后在手机上显示出来更新UI。\n\n> 豆瓣电影API可以在 [这里查看](https://developers.douban.com/wiki/?title=movie_v2) ，此处代码使用的是 榜单 [Top250](https://developers.douban.com/wiki/?title=movie_v2#top250) 这个接口(json返回结果较复杂请耐心分析)。在chrome浏览器中下载 postman 然后输入 https://api.douban.com/v2/movie/top250?start=0&count=10 查看json返回结果。\n\n我们来分析代码，首先通过getMovie() 得到了API所返回的json结果。这里根据提供的json结果返回的格式是\n\nObservable < ApiResult< Subject>> 是一个被观察者Observable （这里真实的场景就是我们通过网络就得到了被观察者而不是自己去创建），然后我们开始多次使用操作符来对这个最原始的 json返回结果进行剥离只留下我们需要的数据，比如这里我只需要榜单中电影的名字。\n\n第一次我们使用了 flatmap 得到了subject ， 然后我们再使用了 map 得到了String 这个对应着电影的名字。此时被观察者所发出的事件中的数据由 Observable < ApiResult< Subject>> 变成了 String 。至此被观察者的事情就处理好了事件源返回了我们想要的那一部分的数据。接下来分别使用 subscribeOn 和 observeOn 来分别指定这些任务应该运行在哪个线程。显然我们指定了观察者的任务处理在 io 线程， 被观察者是运行在主线程中的。最后的最后，我们进行了关注 - 订阅 告诉观察者如果你收到了被观察者的事件通知应该做点什么（setText 更新了UI）。\n\n好，如果你再结合上lambda 表达式的话，代码会看起来更清爽（但是个人不推荐）。\n\n```java\nServiceManager.getInstance()\n                        .getMovieService()\n                        .getMovie(0, 10)\n                        .flatMap(subjectApiResult -> Observable.from(subjectApiResult.getSubjects()))\n                        .map(subject -> subject.getTitle())\n                        .subscribeOn(Schedulers.io())\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(new MySubscriber<String>(context) {\n                            @Override\n                            public void onNext(String s) {\n                                apiResultTv.setText(s);\n                            }\n                        });\n```\n\n总结一下：其实整个这一串代码就是链式下来的一个直的逻辑。\n\n- 得到API返回结果                  getMovie()\n- 转化得到的结果为Subject   flatMap()\n- 转化得到的结果为String      map()\n- 指定线程                                observeOn()  subscribeOn()\n- 订阅                                        subscribe()\n\nRxjava 之所以说它灵活是因为在转化的过程中你想怎么转化都是可以的，它可以通过多种操作符来适应你的各种筛选要求。之后会用一篇文章介绍一下常用的一些操作符。\n\n---\n\n### ​后记\n\n终于告一段落了，Rxjava 的基本介绍就这么多了，希望这边文章能给你们一点点帮助。本文中除了 Rxjava 与 Retrofit结合的代码是原创，剩下的示例代码来自 扔物线。还有如果想了解一下 lambda 表达式的同学可以去 [这里学习](https://loshine.me/2016/03/30/use-lambda-in-android/)\n\n### 特别感谢\n\n- [饭窝](https://loshine.me/)\n\n- [扔物线](https://github.com/rengwuxian)\n\n  ​","content":"<blockquote>\n<p>本文较长建议在电脑上阅读(文中除 RxJava + Retrofit 结合运用部分，其余代码示例来自 扔物线 博客)</p>\n</blockquote>\n<p>2016年也差不多要结束了，作为一个Android小白今年学到的东西回头来看发现还是太少了。给我印象最深的是 MVP设计模式、Retrofit以及RxJava。这篇文章就来讲一下Retrofit和RxJava。</p>\n<p>网上有很多这两者相关的资料但是结合起来的文章比较少，本着我们学习的目的是为了真正在工作项目中使用，所以决定写下这篇文章，本人由于工作经验较少文中出现错误了希望大家指出纠正。</p>\n<p>这里我要先分开讲两者然后再结合起来，只有分开弄清楚了才能在结合的时候运用自如。</p>\n<h1 id=\"​RxJava\"><a href=\"#​RxJava\" class=\"headerlink\" title=\"​RxJava\"></a>​RxJava</h1><p>首先强烈推荐 <a href=\"https://github.com/rengwuxian\" target=\"_blank\" rel=\"external\">扔物线</a> 大大的这篇文章 <a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\"> 《给 Android 开发者的 RxJava 详解》</a> 毫不夸张的说，如果真正吃透了这篇文章肯定是能够理解并使用RxJava了（这篇文章较长，系统的介绍了RxJava）。</p>\n<p>本人也是看了许多RxJava的文章最终发现了这篇文章才对RxJava形成了一个相对清楚的认识和理解。这里我就用我自己的理解在来梳理一下RxJava。</p>\n<h3 id=\"为什么要用Rxjava，以及什么场景下使用\"><a href=\"#为什么要用Rxjava，以及什么场景下使用\" class=\"headerlink\" title=\"为什么要用Rxjava，以及什么场景下使用\"></a>为什么要用Rxjava，以及什么场景下使用</h3><blockquote>\n<p>a library for composing asynchronous and event-based programs by using observable sequences.— from Rxjava github</p>\n<p>通过使用可观察序列来组成异步和基于事件的程序的库。</p>\n</blockquote>\n<p>异步 + 简洁  是Rxjava的关键词 。</p>\n<ul>\n<li>在需要处理异步的场景下使用：Rxjava的本质还是为了处理异步这件事。</li>\n<li>因为Rxjava处理逻辑的十分简洁 ，采用了链式的组织方式使得方便拼接来处理复杂的逻辑。</li>\n</ul>\n<h3 id=\"介绍观察者模式\"><a href=\"#介绍观察者模式\" class=\"headerlink\" title=\"介绍观察者模式\"></a>介绍观察者模式</h3><p>因为Rxjava在处理异步问题的时候采用的是 观察者模式。我们首先来熟悉一下观察者模式。其实对于Android日常开发中我们已经非常熟练的去使用了观察者模式了。我们都使用过Button，写过Button的点击事件。</p>\n<ul>\n<li><strong>名词解释</strong>（熟悉自行跳过直接看 <code>代码实现</code> ）</li>\n</ul>\n<p>所谓的 观察者模式 也可以称为 注册-订阅模式，就拿当下十分流行的直播来类比一下。比如我很喜欢B站的一位阿婆主（咦，好像暴露了什么）。她的每次直播我都想看，假设阿婆主直播的时间不是固定的，那我很有可能错过直播那我应该怎么做才能解决这个问题呢？</p>\n<p>两种方式：</p>\n<ol>\n<li>阿婆主每次直播的时候自己主动通知我（我觉得只有可能我在阿婆主的粉丝群里或者就我一个观众 233才可能这样）</li>\n<li>我在B站上关注了阿婆主。注意噢，这里的关注就是意味着订阅了，也就是说只要阿婆主有直播我就能收到通知。</li>\n</ol>\n<p>至此我想你应该懂了什么叫 注册-订阅（观察者）模式了，就是说只要我订阅了某个事件源（阿婆主开直播），当事件发生时我就能收到通知。好，我们接下来用一张表来更加清晰的看看这个模式的各个部分组成。</p>\n<table>\n<thead>\n<tr>\n<th>观察者（事件处理者）</th>\n<th style=\"text-align:left\">被观察者（搞事者）</th>\n<th style=\"text-align:left\">订阅</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>我</td>\n<td style=\"text-align:left\">阿婆主</td>\n<td style=\"text-align:left\">关注阿婆主这个动作</td>\n</tr>\n</tbody>\n</table>\n<p>现在的直播都是采用观察者模式的，好处就是在于无论阿婆主有多少粉丝只要你关注（订阅）了阿婆主，当阿婆主开直播了，这个事件消息能够发送给所有订阅了的粉丝。也就是不需要阿婆主每一个人去挨个通知了。</p>\n<p>我们现在再回到开头的提到的Button的这个事情。我们换一种说法可以把观察者模式理解成为监听模式。关注阿婆主之后就好像放置了一个监听器一直在监听阿婆主是否开播这个事件。一旦阿婆主开播事件被触发监听器就启动，然后执行相应的处理（观看直播 or 给阿婆主刷刷礼物）。</p>\n<p>所以看到这里写Android的小伙伴是不是觉得监听器有点熟悉，这个在Button上监听它被点击了的监听器不就是OnClickListener吗？当Button（被观察者 or 事件源）被点击之后，OnClickListener（观察者 or 事件处理者）就开始执行相应的操作，可能是跳转Activity也可能是弹出dialog等等。那这个监听器是在哪里订阅或者说关注了Button的一举一动的呢？当然就是在你经常写的 <code>btn.setOnClickListener()</code>的时候啦。在这个时候Button已经被OnClickListener所关注了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Observer  观察者（事件处理者）</th>\n<th>Observable  被观察者（搞事者）</th>\n<th>Subscribe  订阅</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">我</td>\n<td>阿婆主</td>\n<td>关注阿婆主这个动作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OnClickListener   监听器</td>\n<td>Button   按钮</td>\n<td>setOnClickListener   绑定监听</td>\n</tr>\n</tbody>\n</table>\n<p>好的，啰嗦了这么多我为什么要介绍这个观察者模式呢？ 是因为我们Rxjava就是要处理异步问题的，异步一般来说那个不在主线程中的任务会比较耗时，为了防止ANR就会用到观察者模式。观察者不用时时刻刻去查看是否需要更新View了（如果那样好累的说）只要我关注了我需要关注的事件源（比如Button的点击事件）就可以在发生了特定事件的时候获得消息然后再更新View。</p>\n<ul>\n<li><p><strong>代码实现</strong>.</p>\n<p><strong>0 如何引入Rxjava</strong></p>\n<p>Example for Gradle:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// in your modules' build.gradle</span></div><div class=\"line\">   <span class=\"comment\">// Rxjava</span></div><div class=\"line\">   compile <span class=\"string\">'com.squareup.retrofit2:adapter-rxjava:2.0.2'</span></div><div class=\"line\">   <span class=\"comment\">// RXandroid</span></div><div class=\"line\">   compile <span class=\"string\">'io.reactivex:rxandroid:1.0.1'</span></div></pre></td></tr></table></figure>\n<p><strong>1 创建观察者（事件处理者）Observer</strong><br>观察者决定了当事件被触发了做出怎样的回应（在onNext 方法中处理）。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observer&lt;String&gt; observer = <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Item: \"</span> + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Error!\"</span>);</div><div class=\"line\">    &#125;&#125;;</div></pre></td></tr></table></figure>\n<p>​</p>\n<p>首先说明我们在实际的开发中一般创建观察者的时候使用的并不是Observer而是Subscriber。<br>Observer正如其字面的意思就是观察者，是一个接口里面的接口方法就是上面的三个方法，onNext()  onCompleted()  onError() 。而在实际开发中使用到的Subscriber是什么呢？<br>通过查看源码 public abstract class Subscriber<t> implements Observer<t>, Subscription ，原来Subscriber是一个抽象类它实现了 Observer 和 Sbuscription 这两个接口。</t></t></p>\n<ul>\n<li>Observer  — onNext()   onCompleted()  onError()</li>\n<li>subscription — unsubscribe()  isUnsubscribed()</li>\n</ul>\n</li>\n</ul>\n<p>其实Subscriber的用法跟Observer用法基本一致，相比于Observer多了一些重写方法,从表格中可以看出多了<code>unsubscribe()</code> 和 <code>isUnsubscribed()</code> 这两个方法。</p>\n<blockquote>\n<p>新增的这两个接口方法有着重要的意义，<code>unsubscribe()</code> 用于取消订阅。恩，既然我可以关注一个阿婆主当然也能够取消关注嘛。这个方法一般是在 onStop() 或者 onPause() 中去实现，取消订阅释放内存防止内存泄漏。阿婆主我取消对你关注了你不可能还死皮赖脸的缠着不放吧 233 。</p>\n</blockquote>\n<p>下面是 subscribe的创建（其实基本都是一样的）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Subscriber&lt;String&gt; subscriber = <span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Item: \"</span> + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Error!\"</span>);</div><div class=\"line\">    &#125;&#125;;</div></pre></td></tr></table></figure>\n<p><strong>2 创建被观察者（搞事者）Observable</strong></p>\n<p>Observable决定了发送什么事件以及何时发送时间即 what &amp; when。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable observable = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">        subscriber.onNext(<span class=\"string\">\"World\"</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;&#125;);</div></pre></td></tr></table></figure>\n<p>我们从上面的简单例子可以看到不管是观察者还是被观察者处理的数据类型都是基本的String类型。在真实的项目开发中，我们在使用Rxjava + Retrofit 的时候要处理的类型往往是通过服务器给定的，通常事先是不知道的。这就需要我们在类型的地方使用泛型来处理，这里只是简单的示例。</p>\n<blockquote>\n<p>除了可以使用 create来创建一个被观察者还可以使用just 和 from， 而这些都被称作操作符，大家可以去<a href=\"https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html\" target=\"_blank\" rel=\"external\">这里</a> 了解一下。</p>\n</blockquote>\n<p><strong>3 订阅Subscribe</strong></p>\n<p>只要在 Observable中订阅一下，将Observe与其连接起来就是完成订阅了。</p>\n<p>举例说明一下：</p>\n<p>由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> drawableRes = ...;</div><div class=\"line\">ImageView imageView = ...;</div><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Drawable&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        Drawable drawable = getTheme().getDrawable(drawableRes));</div><div class=\"line\">        subscriber.onNext(drawable);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;Drawable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Drawable drawable)</span> </span>&#123;</div><div class=\"line\">        imageView.setImageDrawable(drawable);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Toast.makeText(activity, <span class=\"string\">\"Error!\"</span>, Toast.LENGTH_SHORT).show();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>好，至此我们已经看到了整个观察者模式一个完整的流程了即创建 Observable 和 Observe 然后通过 Subscribe 连接两者即可。</p>\n<h3 id=\"真正的使用Rxjava\"><a href=\"#真正的使用Rxjava\" class=\"headerlink\" title=\"真正的使用Rxjava\"></a>真正的使用Rxjava</h3><p>在上面一节 介绍观察者模式中我们提出来完整的流程，我们也就基本的了解了Rxjava的工作流程，但是这不是Rxjava真正的使用方式！</p>\n<p>因为我们使用Rxjava的最初目的还是处理 异步问题。而目前为止所看到的所有代码都是在同一个线程中执行的，所以并不是Rxjava真正的使用方式。接下来，我们就要在不同的线程之间去使用Rxjava。</p>\n<p>为了在不同的线程中去使用Rxjava这就表明我们需要线程切换。我在A线程做一件事情，然后切换到B线程去做另外一件事情。刚好Rxjava提供了调度器，它可以用来切换线程。在Rxjava中使用Schedulars — 调度器来切换线程。该调度器已经默认提供了一些线程可供我们使用。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法名</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">immediate()</td>\n<td style=\"text-align:left\">在当前线程中执行(缺省模式)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">computation()</td>\n<td style=\"text-align:left\">计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">io()</td>\n<td style=\"text-align:left\">I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">newThread()</td>\n<td style=\"text-align:left\">总是创建新的线程，并在新的线程中执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mainThread()</td>\n<td style=\"text-align:left\">Android中的主线程</td>\n</tr>\n</tbody>\n</table>\n<p>一般在实际的项目中用到最多的就是 io  newThread 以及 mainThread 这三个线程。在被观察者中 Observable提供了 两个方式分别是 <code>subscribeOn()</code>  和 <code>observeOn()</code>  来指定观察者和被观察者分别运行在哪个线程。</p>\n<p>举例说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServiceManager.getInstance()</div><div class=\"line\">                        .getMovieService()</div><div class=\"line\">                        .getMovie(<span class=\"number\">0</span>, <span class=\"number\">10</span>)</div><div class=\"line\">                        .subscribeOn(Schedulers.newThread())</div><div class=\"line\">                        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                        .subscribe(<span class=\"keyword\">new</span> MySubscriber&lt;ApiResult&lt;Subject&gt;&gt;(context) &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(ApiResult&lt;Subject&gt; subjectApiResult)</span> </span>&#123;</div><div class=\"line\">                                <span class=\"comment\">// do something</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div></pre></td></tr></table></figure>\n<p>从这个例子上我们可以看到  观察者是运行在新的线程上而  被观察者则是运行在主线程上。注意看在subscribeOn() 的前一句是获取电影的相关信息  getMovie()， 而获取这个信息需要的时间可能较长且不确定所以放在了另外一个新的线程中去执行你可以说实在后台线程执行。最后得到数据之后在再主线程中进行相应的处理。（这里已经是使用了Rxjava + Retrofit）</p>\n<h3 id=\"Rxjava是如此的灵活\"><a href=\"#Rxjava是如此的灵活\" class=\"headerlink\" title=\"Rxjava是如此的灵活\"></a>Rxjava是如此的灵活</h3><p>如果你能看到这里非常感谢，以上的内容都是介绍和解释了Rxjava 是如何处理异步问题。还记得文章最开头提到的Rxjava的两个关键词吗？ 异步 +  简洁， 这一节就要介绍Rxjava为什么相比于其他处理异步问题的方式为什么简洁、灵活。</p>\n<p>我们先来说说什么样的逻辑是容易被理解的。我个人认为直的逻辑，换句话说不需要考虑各种分支各种例外情况或者是多层关系的逻辑是容易被理解的（层级、依赖、分支较少的逻辑我认为就是直的逻辑）。好比路线，一条直路就能到达目的地当时给人的感觉是清晰、简单的。恰好，Rxjava就是这种链式的一条直的逻辑。依靠着众多 操作符 能够非常方便的实现拼积木的感觉（多了直接扔掉，少了直接加上就好不用考虑依赖、层级之间的关系）。</p>\n<p>举例演示一下（注意这里Rxjava和Retrofit结合在使用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServiceManager.getInstance()</div><div class=\"line\">                        .getMovieService()</div><div class=\"line\">                        .getMovie(<span class=\"number\">0</span>, <span class=\"number\">10</span>)</div><div class=\"line\">                        .flatMap(<span class=\"keyword\">new</span> Func1&lt;ApiResult&lt;Subject&gt;, Observable&lt;Subject&gt;&gt;() &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Subject&gt; <span class=\"title\">call</span><span class=\"params\">(ApiResult&lt;Subject&gt; subjectApiResult)</span> </span>&#123;</div><div class=\"line\">                                <span class=\"keyword\">return</span> Observable.from(subjectApiResult.getSubjects());</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;)</div><div class=\"line\">                        .map(<span class=\"keyword\">new</span> Func1&lt;Subject, String&gt;() &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Subject subject)</span> </span>&#123;</div><div class=\"line\">                                <span class=\"keyword\">return</span> subject.getTitle();</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;)</div><div class=\"line\">                        .subscribeOn(Schedulers.io())</div><div class=\"line\">                        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                        .subscribe(<span class=\"keyword\">new</span> MySubscriber&lt;String&gt;(context) &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                                apiResultTv.setText(s);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div></pre></td></tr></table></figure>\n<p>ok,对于刚刚接触Rxjava的人可能一下子会觉得真正使用Rxjava是这么的麻烦，看着代码好像很多逻辑反而不清晰呢。其实这只是由于新接触Rxjava被表面的代码书写格式所吓到了而已。下面来分析一下这一串代码，首先介绍一下背景：</p>\n<p>我通过豆瓣电影API得到电影Top250 的相关信息，然后在手机上显示出来更新UI。</p>\n<blockquote>\n<p>豆瓣电影API可以在 <a href=\"https://developers.douban.com/wiki/?title=movie_v2\" target=\"_blank\" rel=\"external\">这里查看</a> ，此处代码使用的是 榜单 <a href=\"https://developers.douban.com/wiki/?title=movie_v2#top250\" target=\"_blank\" rel=\"external\">Top250</a> 这个接口(json返回结果较复杂请耐心分析)。在chrome浏览器中下载 postman 然后输入 <a href=\"https://api.douban.com/v2/movie/top250?start=0&amp;count=10\" target=\"_blank\" rel=\"external\">https://api.douban.com/v2/movie/top250?start=0&amp;count=10</a> 查看json返回结果。</p>\n</blockquote>\n<p>我们来分析代码，首先通过getMovie() 得到了API所返回的json结果。这里根据提供的json结果返回的格式是</p>\n<p>Observable &lt; ApiResult&lt; Subject&gt;&gt; 是一个被观察者Observable （这里真实的场景就是我们通过网络就得到了被观察者而不是自己去创建），然后我们开始多次使用操作符来对这个最原始的 json返回结果进行剥离只留下我们需要的数据，比如这里我只需要榜单中电影的名字。</p>\n<p>第一次我们使用了 flatmap 得到了subject ， 然后我们再使用了 map 得到了String 这个对应着电影的名字。此时被观察者所发出的事件中的数据由 Observable &lt; ApiResult&lt; Subject&gt;&gt; 变成了 String 。至此被观察者的事情就处理好了事件源返回了我们想要的那一部分的数据。接下来分别使用 subscribeOn 和 observeOn 来分别指定这些任务应该运行在哪个线程。显然我们指定了观察者的任务处理在 io 线程， 被观察者是运行在主线程中的。最后的最后，我们进行了关注 - 订阅 告诉观察者如果你收到了被观察者的事件通知应该做点什么（setText 更新了UI）。</p>\n<p>好，如果你再结合上lambda 表达式的话，代码会看起来更清爽（但是个人不推荐）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServiceManager.getInstance()</div><div class=\"line\">                        .getMovieService()</div><div class=\"line\">                        .getMovie(<span class=\"number\">0</span>, <span class=\"number\">10</span>)</div><div class=\"line\">                        .flatMap(subjectApiResult -&gt; Observable.from(subjectApiResult.getSubjects()))</div><div class=\"line\">                        .map(subject -&gt; subject.getTitle())</div><div class=\"line\">                        .subscribeOn(Schedulers.io())</div><div class=\"line\">                        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                        .subscribe(<span class=\"keyword\">new</span> MySubscriber&lt;String&gt;(context) &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                                apiResultTv.setText(s);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div></pre></td></tr></table></figure>\n<p>总结一下：其实整个这一串代码就是链式下来的一个直的逻辑。</p>\n<ul>\n<li>得到API返回结果                  getMovie()</li>\n<li>转化得到的结果为Subject   flatMap()</li>\n<li>转化得到的结果为String      map()</li>\n<li>指定线程                                observeOn()  subscribeOn()</li>\n<li>订阅                                        subscribe()</li>\n</ul>\n<p>Rxjava 之所以说它灵活是因为在转化的过程中你想怎么转化都是可以的，它可以通过多种操作符来适应你的各种筛选要求。之后会用一篇文章介绍一下常用的一些操作符。</p>\n<hr>\n<h3 id=\"​后记\"><a href=\"#​后记\" class=\"headerlink\" title=\"​后记\"></a>​后记</h3><p>终于告一段落了，Rxjava 的基本介绍就这么多了，希望这边文章能给你们一点点帮助。本文中除了 Rxjava 与 Retrofit结合的代码是原创，剩下的示例代码来自 扔物线。还有如果想了解一下 lambda 表达式的同学可以去 <a href=\"https://loshine.me/2016/03/30/use-lambda-in-android/\" target=\"_blank\" rel=\"external\">这里学习</a></p>\n<h3 id=\"特别感谢\"><a href=\"#特别感谢\" class=\"headerlink\" title=\"特别感谢\"></a>特别感谢</h3><ul>\n<li><p><a href=\"https://loshine.me/\" target=\"_blank\" rel=\"external\">饭窝</a></p>\n</li>\n<li><p><a href=\"https://github.com/rengwuxian\" target=\"_blank\" rel=\"external\">扔物线</a></p>\n<p>​</p>\n</li>\n</ul>\n","slug":"Retrofit-RxJava-从入门到跑路（Rxjava介绍）","updated":"2017-06-26T09:49:08.203Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2016/12/26/Retrofit-RxJava-从入门到跑路（Rxjava介绍）/","excerpt":"","categories":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/tags/Android/"}]},{"title":"做一个Android计算器","date":"2016-12-11T11:31:43.000Z","path":"2016/12/11/做一个Android计算器，我学到了什么/","text":"知识点清单 TableLayout 相关知识 AnimationSet 相关知识（简单的动画效果实现） 可选 butterknife（声明 View 控件的另一种方式） 核心思路通过 后缀表达式 来计算输入的算式，是本程序逻辑的重点。 先来解释一下为什么做一个计算器会用到 后缀表达式 。我们人脑在处理算式的时候是按照 中缀表达式 的方式来处理的。比如：6 - 4 ，我们大脑处理这个算式的顺序很自然的就是6减去4最后得到结果。如果更复杂一些的算式如：6 - 4 x 3 ，我们第一反应是根据运算符的优先级别决定先运算4 x 3 然后再用6减去之前得到的结果。 综上所述，我们人脑在计算算式的时候其实是按照 中缀表达式 的顺序来计算的。但是如果我们程序采用这种方式来计算算式编写的逻辑会十分的麻烦，所以这里我们就提出来 后缀表达式 来方便程序逻辑的编写，同时也是方便计算机处理。所以在编写的逻辑中我们有着关键一步就是把 中缀表达式 转换成为 后缀表达式 。 好了，我们来从全局整理一下我们编写计算器的逻辑。 1 得到用户输入的算式（此算式为中缀表达式所表示）。 2 将此中缀表达式转化成后缀表达式。 3 计算转化得到的后缀表达式得出算式结果。 实现步骤项目地址 这里只讨论关键思路，详细的代码请查看项目地址中的代码。 获得用户输入的具体过程 按照中缀表达式（即从左到右的顺序把 String 存到栈中） 1 用 num 作为一个存放数字或者点号的临时变量。 2 判断当前要存入栈的字符是 运算符 还是 数字或者点号。 3 交替的存入 num 和 运算符。 ps：需要注意的一种情况是。用户输入进来的字符串的第一个字符是 运算符，若为此种情况应当在该字符串的首位添加一个0保证后续计算的正确性！（若没有添加0，在使用后缀表达式计算的时候会由于缺少一个运算数报错）。 举例：用户此时的输入是 -6-2 ， 按照后缀表达式的规则先把该式子写成后缀表达式为 6-2- ，然后按照后缀表达式的计算规则，当读到运算符（第一个减号）的时候，弹出前面入栈的两个元素进行计算，但此时在减号前面入栈的只有6这一个元素无法计算，因此报错。 把中缀表达式转变成后缀表达式（重点讨论） 1 建立两个栈， 一个是存放转化成为后缀表达式的栈 A，一个是存放运算符的栈 B。 2 首先根据上一步，我们已经保证了得到的输入字符串的首位肯定是一个数字。开始进行转化逻辑如下： ​ 从左向右依次读取字符串 ​ 2.1 如果是数字或者点号存入到 A ​ 2.2 如果是运算符，一 当 B 栈为空则直接放入 B； 二 B 栈不为空把该栈顶元素与当前得到的元算符进行优先级比较。如果运算符栈顶运算符的优先级大于当前运算符则把栈顶运算符存入到 A ，把当前运算符存入到 B 中；如果运算符栈顶元素的优先级小于当前元算符，则直接把当前运算符存入到 B 中。 ​ 2.3 检查 B 栈 ， 如果还有元素存在则都存入 A 中。 ​ 3 最终得到 A 栈中的结果就是用后缀表达式的方式所表示的字符串。 举例：中缀表达式为 6-5x4 1 把6放入栈 A 中。 2 把减号放入栈 B 中。 3 5放入栈 A 中。 4 乘号由于比 B 中的减号优先级高则直接放入栈 B 中。（此时是运算符栈顶元素减号优先级小于当前元素乘号的情况）。 5 把4放入栈中 此时两个栈的情况是： A ：654； B：-X ； 6 最后把 B 中的元素弹出依次放入 A 中，最终得到的后缀表达式为 654x- 举例：中缀表达式为6x5-4 1 存入6到 A 栈中。 2 把乘号放入运算符栈 B 3 5存入栈 A 中。 4 减号是当前元素由于元算符 B 栈顶元素是乘号优先级高于减号，所以弹出 B 栈的栈顶元素即乘号放入 A 中，然后把当前元素 减号 再放入 B 中。此时两个栈的情况为： A：65x ； B：- ； 5 把4放入 A 中。 6 把 B 中所有的元素（若有）放入 A 中，即把减号放入 A 中。最终得到的后缀表达式为 65X4- 计算后缀表达式 从左至右依次读取由后缀表达式表示的字符串 1 如果读到当前字符是数字或者点号则存入栈中。 2 如果读到运算符则把栈顶的两个元素弹出来然后用该运算符对其计算，所得到的结果再存入栈中。 以上就是整个计算器实现的关键思路了，详细的代码可以去项目查看。如果你有什么问题可以在项目中 讨论 中交流。 对了对了，最后如果你也喜爱二次元或者喜爱翻唱欢迎来加微博，在博客的左边。","raw":"---\ntitle: 做一个Android计算器\ndate: 2016-12-11 19:31:43\ntags: Android\ncategories: Android\n---\n\n## 知识点清单\n\n- TableLayout 相关知识\n- AnimationSet 相关知识（简单的动画效果实现）\n- 可选 [butterknife](https://github.com/JakeWharton/butterknife)（声明 View 控件的另一种方式）\n\n## 核心思路\n\n通过  `后缀表达式`  来计算输入的算式，是本程序逻辑的重点。\n\n先来解释一下为什么做一个计算器会用到  `后缀表达式` 。我们人脑在处理算式的时候是按照  `中缀表达式`  的方式来处理的。比如：6 - 4  ，我们大脑处理这个算式的顺序很自然的就是6减去4最后得到结果。如果更复杂一些的算式如：6 - 4 x 3 ，我们第一反应是根据运算符的优先级别决定先运算4 x 3 然后再用6减去之前得到的结果。\n\n**综上所述，我们人脑在计算算式的时候其实是按照  `中缀表达式` 的顺序来计算的。**但是如果我们程序采用这种方式来计算算式编写的逻辑会十分的麻烦，所以这里我们就提出来  `后缀表达式`  来方便程序逻辑的编写，同时也是方便计算机处理。所以在编写的逻辑中我们有着关键一步就是把 `中缀表达式`  转换成为 `后缀表达式` 。\n\n好了，我们来从全局整理一下我们编写计算器的逻辑。\n\n1  得到用户输入的算式（此算式为中缀表达式所表示）。\n\n2  将此中缀表达式转化成后缀表达式。\n\n3  计算转化得到的后缀表达式得出算式结果。 \n\n## 实现步骤\n\n[项目地址](https://coding.net/u/jammic/p/JCalculator/git)\n\n这里只讨论关键思路，详细的代码请查看项目地址中的代码。\n\n- **获得用户输入的具体过程**\n\n  *按照中缀表达式（即从左到右的顺序把 String 存到栈中）*\n\n  1  用 `num` 作为一个存放数字或者点号的临时变量。\n\n  2  判断当前要存入栈的字符是 运算符 还是 数字或者点号。\n\n  3  交替的存入 `num`  和 运算符。\n\n  ps：`需要注意的一种情况是。用户输入进来的字符串的第一个字符是 运算符，若为此种情况应当在该字符串的首位添加一个0保证后续计算的正确性！（若没有添加0，在使用后缀表达式计算的时候会由于缺少一个运算数报错）。`\n\n  > 举例：用户此时的输入是  -6-2 ， 按照后缀表达式的规则先把该式子写成后缀表达式为 6-2- ，然后按照后缀表达式的计算规则，当读到运算符（第一个减号）的时候，弹出前面入栈的两个元素进行计算，但此时在减号前面入栈的只有6这一个元素无法计算，因此报错。\n\n- **把中缀表达式转变成后缀表达式（重点讨论）**\n\n   1  建立两个栈， 一个是存放转化成为后缀表达式的栈 A，一个是存放运算符的栈 B。\n\n   2  首先根据上一步，我们已经保证了得到的输入字符串的首位肯定是一个数字。开始进行转化逻辑如下：\n\n  ​\t*从左向右依次读取字符串*\n\n  ​     2.1  如果是数字或者点号存入到 A  \n\n  ​     2.2  如果是运算符，一 当 B 栈为空则直接放入 B； 二  B 栈不为空把该栈顶元素与当前得到的元算符进行优先级比较。如果运算符栈顶运算符的优先级大于当前运算符则把栈顶运算符存入到  A  ，把当前运算符存入到 B 中；如果运算符栈顶元素的优先级小于当前元算符，则直接把当前运算符存入到 B 中。\n\n  ​     2.3  检查 B 栈 ， 如果还有元素存在则都存入  A  中。\n\n​         3  最终得到  A 栈中的结果就是用后缀表达式的方式所表示的字符串。\n\n> 举例：中缀表达式为 6-5x4\n>\n> 1  把6放入栈 A 中。\n>\n> 2  把减号放入栈 B 中。\n>\n> 3  5放入栈  A  中。\n>\n> 4   乘号由于比  B  中的减号优先级高则直接放入栈 B 中。（此时是运算符栈顶元素减号优先级小于当前元素乘号的情况）。\n>\n> 5  把4放入栈中\n>\n> 此时两个栈的情况是： A ：654；  B：-X  ；\n>\n> 6  最后把 B 中的元素弹出依次放入 A 中，最终得到的后缀表达式为 654x-\n\n<br>\n\n> 举例：中缀表达式为6x5-4\n>\n> 1 存入6到 A 栈中。\n>\n> 2  把乘号放入运算符栈 B\n>\n> 3  5存入栈 A 中。\n>\n> 4  减号是当前元素由于元算符 B 栈顶元素是乘号优先级高于减号，所以弹出 B 栈的栈顶元素即乘号放入 A 中，然后把当前元素 减号 再放入 B 中。此时两个栈的情况为： A：65x ； B：-  ；\n>\n> 5  把4放入 A  中。\n>\n> 6  把 B 中所有的元素（若有）放入 A 中，即把减号放入 A 中。最终得到的后缀表达式为 65X4-\n\n- **计算后缀表达式**\n\n  *从左至右依次读取由后缀表达式表示的字符串*\n\n  1  如果读到当前字符是数字或者点号则存入栈中。\n\n  2  如果读到运算符则把栈顶的两个元素弹出来然后用该运算符对其计算，所得到的结果再存入栈中。\n\n---\n\n以上就是整个计算器实现的关键思路了，详细的代码可以去[项目](https://coding.net/u/jammic/p/JCalculator/git)查看。如果你有什么问题可以在项目中 `讨论`  中交流。\n\n对了对了，最后如果你也喜爱二次元或者喜爱翻唱欢迎来加微博，在博客的左边。\n\n\n\n\n","content":"<h2 id=\"知识点清单\"><a href=\"#知识点清单\" class=\"headerlink\" title=\"知识点清单\"></a>知识点清单</h2><ul>\n<li>TableLayout 相关知识</li>\n<li>AnimationSet 相关知识（简单的动画效果实现）</li>\n<li>可选 <a href=\"https://github.com/JakeWharton/butterknife\" target=\"_blank\" rel=\"external\">butterknife</a>（声明 View 控件的另一种方式）</li>\n</ul>\n<h2 id=\"核心思路\"><a href=\"#核心思路\" class=\"headerlink\" title=\"核心思路\"></a>核心思路</h2><p>通过  <code>后缀表达式</code>  来计算输入的算式，是本程序逻辑的重点。</p>\n<p>先来解释一下为什么做一个计算器会用到  <code>后缀表达式</code> 。我们人脑在处理算式的时候是按照  <code>中缀表达式</code>  的方式来处理的。比如：6 - 4  ，我们大脑处理这个算式的顺序很自然的就是6减去4最后得到结果。如果更复杂一些的算式如：6 - 4 x 3 ，我们第一反应是根据运算符的优先级别决定先运算4 x 3 然后再用6减去之前得到的结果。</p>\n<p><strong>综上所述，我们人脑在计算算式的时候其实是按照  <code>中缀表达式</code> 的顺序来计算的。</strong>但是如果我们程序采用这种方式来计算算式编写的逻辑会十分的麻烦，所以这里我们就提出来  <code>后缀表达式</code>  来方便程序逻辑的编写，同时也是方便计算机处理。所以在编写的逻辑中我们有着关键一步就是把 <code>中缀表达式</code>  转换成为 <code>后缀表达式</code> 。</p>\n<p>好了，我们来从全局整理一下我们编写计算器的逻辑。</p>\n<p>1  得到用户输入的算式（此算式为中缀表达式所表示）。</p>\n<p>2  将此中缀表达式转化成后缀表达式。</p>\n<p>3  计算转化得到的后缀表达式得出算式结果。 </p>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p><a href=\"https://coding.net/u/jammic/p/JCalculator/git\" target=\"_blank\" rel=\"external\">项目地址</a></p>\n<p>这里只讨论关键思路，详细的代码请查看项目地址中的代码。</p>\n<ul>\n<li><p><strong>获得用户输入的具体过程</strong></p>\n<p><em>按照中缀表达式（即从左到右的顺序把 String 存到栈中）</em></p>\n<p>1  用 <code>num</code> 作为一个存放数字或者点号的临时变量。</p>\n<p>2  判断当前要存入栈的字符是 运算符 还是 数字或者点号。</p>\n<p>3  交替的存入 <code>num</code>  和 运算符。</p>\n<p>ps：<code>需要注意的一种情况是。用户输入进来的字符串的第一个字符是 运算符，若为此种情况应当在该字符串的首位添加一个0保证后续计算的正确性！（若没有添加0，在使用后缀表达式计算的时候会由于缺少一个运算数报错）。</code></p>\n<blockquote>\n<p>举例：用户此时的输入是  -6-2 ， 按照后缀表达式的规则先把该式子写成后缀表达式为 6-2- ，然后按照后缀表达式的计算规则，当读到运算符（第一个减号）的时候，弹出前面入栈的两个元素进行计算，但此时在减号前面入栈的只有6这一个元素无法计算，因此报错。</p>\n</blockquote>\n</li>\n<li><p><strong>把中缀表达式转变成后缀表达式（重点讨论）</strong></p>\n<p> 1  建立两个栈， 一个是存放转化成为后缀表达式的栈 A，一个是存放运算符的栈 B。</p>\n<p> 2  首先根据上一步，我们已经保证了得到的输入字符串的首位肯定是一个数字。开始进行转化逻辑如下：</p>\n<p>​    <em>从左向右依次读取字符串</em></p>\n<p>​     2.1  如果是数字或者点号存入到 A  </p>\n<p>​     2.2  如果是运算符，一 当 B 栈为空则直接放入 B； 二  B 栈不为空把该栈顶元素与当前得到的元算符进行优先级比较。如果运算符栈顶运算符的优先级大于当前运算符则把栈顶运算符存入到  A  ，把当前运算符存入到 B 中；如果运算符栈顶元素的优先级小于当前元算符，则直接把当前运算符存入到 B 中。</p>\n<p>​     2.3  检查 B 栈 ， 如果还有元素存在则都存入  A  中。</p>\n</li>\n</ul>\n<p>​         3  最终得到  A 栈中的结果就是用后缀表达式的方式所表示的字符串。</p>\n<blockquote>\n<p>举例：中缀表达式为 6-5x4</p>\n<p>1  把6放入栈 A 中。</p>\n<p>2  把减号放入栈 B 中。</p>\n<p>3  5放入栈  A  中。</p>\n<p>4   乘号由于比  B  中的减号优先级高则直接放入栈 B 中。（此时是运算符栈顶元素减号优先级小于当前元素乘号的情况）。</p>\n<p>5  把4放入栈中</p>\n<p>此时两个栈的情况是： A ：654；  B：-X  ；</p>\n<p>6  最后把 B 中的元素弹出依次放入 A 中，最终得到的后缀表达式为 654x-</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>举例：中缀表达式为6x5-4</p>\n<p>1 存入6到 A 栈中。</p>\n<p>2  把乘号放入运算符栈 B</p>\n<p>3  5存入栈 A 中。</p>\n<p>4  减号是当前元素由于元算符 B 栈顶元素是乘号优先级高于减号，所以弹出 B 栈的栈顶元素即乘号放入 A 中，然后把当前元素 减号 再放入 B 中。此时两个栈的情况为： A：65x ； B：-  ；</p>\n<p>5  把4放入 A  中。</p>\n<p>6  把 B 中所有的元素（若有）放入 A 中，即把减号放入 A 中。最终得到的后缀表达式为 65X4-</p>\n</blockquote>\n<ul>\n<li><p><strong>计算后缀表达式</strong></p>\n<p><em>从左至右依次读取由后缀表达式表示的字符串</em></p>\n<p>1  如果读到当前字符是数字或者点号则存入栈中。</p>\n<p>2  如果读到运算符则把栈顶的两个元素弹出来然后用该运算符对其计算，所得到的结果再存入栈中。</p>\n</li>\n</ul>\n<hr>\n<p>以上就是整个计算器实现的关键思路了，详细的代码可以去<a href=\"https://coding.net/u/jammic/p/JCalculator/git\" target=\"_blank\" rel=\"external\">项目</a>查看。如果你有什么问题可以在项目中 <code>讨论</code>  中交流。</p>\n<p>对了对了，最后如果你也喜爱二次元或者喜爱翻唱欢迎来加微博，在博客的左边。</p>\n","slug":"做一个Android计算器，我学到了什么","updated":"2017-06-26T12:52:33.478Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2016/12/11/做一个Android计算器，我学到了什么/","excerpt":"","categories":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://jngoogle.github.io/tags/Android/"}]},{"title":"Hello World","date":"2016-12-09T10:18:11.602Z","path":"2016/12/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","slug":"hello-world","updated":"2016-12-09T10:18:11.603Z","comments":true,"link":"","permalink":"https://jngoogle.github.io/2016/12/09/hello-world/","excerpt":"","categories":[],"tags":[]}]}