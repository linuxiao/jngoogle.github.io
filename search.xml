<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[创建型模式之单例模式]]></title>
      <url>%2F2017%2F06%2F29%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[前言 ps: 本文较长，请分段阅读 上图列举出来所有设计模式的结构图，这次就来看看单例模式。 在软件设计中，许多地方用到的实例是不需要创建多个实例，例如在 Windows 系统中有且仅有一个任务管理器（它也确实不需要多个，并且如果有多个将出现很多问题）。不管是实际情况的需要还是为了提高性能，当我们只需要一个实例的时候就可以使用单例模式来设计。 我们就从日常开发中使用最多的 单例模式 开始我们的设计模式学习。 单例模式的定义单例模式的定义是：确保某一个类只有一个实例，并自行实例化且向整个系统提供这个实例。 只有一个实例 必须是自行实例化 提供全局访问的方法 如何实现单例模式第1步创建一个类假设是 SingleInstance，然后保证它的构造方法（无参数）的访问权限是 private ，避免外部类使用 new 创建多个实例（此时外部类无法使用 new 来创建该单例）。 第2步创建 SingleInstance中的成员变量假设是 sInstance（类型是 SingleInstance） ，使用 private 和 static 进行修饰即私有的静态变量，保证其是该 单例的唯一实例。 第3步在 SingleInstance类中创建一个 public 修饰的公共方法 getInstance ，提供给外部类调用该方法来引用这个单例。 具体实现方式实现单例模式有几种不同的方法，下面逐一来看看这几种使用单例的方式。 饿汉式方法特点： 直接在类中 new 出成员变量。 12345678910public class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 这种实现方式由于直接 new 出了成员变量，所以在类被加载的时候同时就会创建该单例。在 getInstance 方法中就可以直接返回 sInstance 这个单例。 需要注意的是创建该类的构造方法的时候要使用 private 修饰，保证外部类不可以使用 new 来创建多个实例。 总结： 当单例类构造方法比较简单，逻辑不复杂的时候可以采用（但是并不推荐），一般来说开发的过程中不要使用 饿汉式 来实现单例模式。 如果类的构造方法复杂，可能会导致类加载很慢。 类加载的时候没有真正的调用，浪费内存资源。 懒汉式为了解决 饿汉式 存在的问题，我们可以采用懒汉式的方式来实现单例模式。 方法特点： 不直接在类中 new 出成员变量。 123456789101112public class SingleInstance &#123; private static SingleInstance sInstance = null; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 该方法解决掉了之前 饿汉式 的性能问题，但是当处于多个线程的时候我们使用上述代码会出现一个严重的问题。嗯，聚个栗子： 现在有两个线程分别为 A 线程、B 线程（简称 A 和 B）。 当 A 执行上面的代码，第一次实例化的时候判断 sInstance 是否为 null，现在为 null 则在 A 中开始创建 SingleInstance 如果创建这个类需要很长的时间,在这个时候 B 线程也执行了上面的代码。B 线程中由于在 A 中的实例还在创建中没有完成，所以 B 中会判断 sInstance 为 null，然后也开始创建实例了。这就导致创建了两个实例，不符合单例模式的设计。 要解决这个问题就是让 A 在执行上面代码的时候，B 线程不能执行直到 A 执行完成了。这样 B 再执行的时候 sInstance 就不是 null 了，自然也就不会再创建新的实例了。 使用线程锁就可以实现上述过程，所以我们修改代码如下： 123456789101112public class SingleInstance &#123; private static SingleInstance sInstance = null; private SingleInstance() &#123; &#125; synchronized public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized 是可以保证多线程、单一实例的方法。有了这个线程锁，很多线程都要执行上面代码的时候就必须要排队，一个一个的来。前面的线程没有使用完这个方法，后面来的线程是没有权限执行这个方法的。 ok，一般开发中大家可能都是使用的 懒汉式 这种实现方式。 但是有一个问题。如果多个线程都要执行这块代码，当第一个线程执行完了这块代码创建了实例。后面的线程才能执行代码去获取 synchronized 这个线程锁，注意获取它是一个耗时操作，但是此时实例已经创建了其实已经没有必要再去获取线程锁了。这里就造成了性能低下的问题。 总结： 通过使用 synchronized 解决了多线程的问题但是此方式效率并不高，不推荐。 双重检查锁定方式 double-checked locking由于获取线程锁 synchronized 是一个耗时的操作，要解决 懒汉式 的问题出现了 双重检查锁定的方式。 该方法的思路也很简单，就是如果这个实例由前面的线程创建了的话，后面的线程在执行代码的时候先判断有没有这个实例，如果有了就不去获取线程锁直接返回已经创建好的实例；没有的话才会去创建实例。 12345678910111213141516public class SingleInstance &#123; private static volatile SingleInstance sInstance = null; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance) &#123; synchronized (SingleInstance.class) &#123; if (null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; 代码中可以很清除的看到在 getInstance() 方法中，首先是判断 sInstance 是否为 null 。假设现在 A 和 B 两个线程，现在是 A 先执行上面的代码假设 A 已经创建好了实例，当 B 进入 getInstance() 方法后，先判断实例是否已经存在，此时是存在的所以不需要获取线程锁去创建实例直接返回实例即可。这样后面的线程不需要去获得线程锁大大提高了执行的效率。 可能你会问为什么需要双重检查？ 在 Synchronized 中为什么还需要判断实例是否为空呢？我们举个比较特殊的 同样我们有两个线程 A 和 B。现在我们假设这两个线程同时调用该方法（现在是可以同时调用 getInstance() 方法的，由于没有 synchronized 线程锁）。两个线程同时进入 getInstance() 方法同时在判断实例是否为空，好，此时都判断为空，这个时候假定 A 先获得了线程锁进入方法中去创建实例。当创建完成之后，A 释放，B 获得线程锁进入方法，如果这个时候不判断实例是否存在，则 B 就会创建实例，最终就有了两个实例了。 ok, 解决了双重检查的问题最最重要的一点还没有提到就是 volatile 这个东西了。 注意在 SingleInstance 类中定义成员变量 sInstance 的时候是用了这个词的。那 volatile 是什么呢？这个具体等下下一篇来说，因为内容较多就不放在这一篇里了，不过你可以去参考一下 这里。 IoDH 方式饿汉式不能实现延迟加载，不管使用与否都将占用内存；懒汉式线程安全需要去控制线程锁比较麻烦。那么现在还有一种方式来同时有两种方式的优点并且去掉他们的缺陷！它被称为 Initialization Demand Holder（IoDH）方式。 123456789101112public class SingleInstance &#123; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return SingleInstanceHolder.sInstance; &#125; private static class SingleInstanceHolder &#123; private static SingleInstance sInstance = new SingleInstance(); &#125;&#125; 在类中创建了一个静态持有类 SingleInstanceHolder 。利用静态类在被加载的时候才会创建的特性，故当 SingleInstance类被加载的时候，如果此时没有加载 SingleInstanceHolder 则该类并不会被加载。这样就能保证在类没有被调用的时候不会占用内存。我们在公有方法中通过该类引用到单例实例。 总结： IoDH 方式综合了了饿汉式 和 懒汉式 两种方式的优点同时也避免了缺陷。 参考链接 《设计模式 java 版》- sunny Double-checked locking and the Singleton pattern 单例这种设计模式 - 技术小黑屋]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit + Rxjava 从入门到跑路（Retrofit介绍）]]></title>
      <url>%2F2016%2F12%2F29%2FRetrofit-Rxjava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Retrofit%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Retrofit介绍Retrofit是什么简单的一句话是一个网络库用来处理一些网络上的数据传输。 Type-safe HTTP client for Android and Java by Square, Inc. 适用于Android 和 Java 的类型安全的Http 客户端 如何使用Retrofit一 配置 Retrofit使用 Gradle 方式添加依赖： 12345678// rxAndroidcompile 'io.reactivex:rxandroid:1.0.1'// retrofit2compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'compile 'com.squareup.retrofit2:retrofit:2.0.2'compile 'com.squareup.retrofit2:converter-gson:2.0.2'// network interceptorcompile 'com.squareup.okhttp3:logging-interceptor:3.1.2' ps: 注意 converter-gson 是一个转换器，你还可以在以下转换器中选择（本文使用Gson作为例子）： Gson: com.squareup.retrofit2:converter-gson （google 官方推荐） Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 我们还可以在 gradle 中添加 网络拦截器，方便调试。 添加网络调试：compile &#39;com.squareup.okhttp3:logging-interceptor:3.1.2&#39; 同时如果要使用 rxjava rxAndroid 与 retrofit 搭配使用，需要添加以下依赖 compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39; compile &#39;io.reactivex:rxandroid:1.0.1&#39; 二 创建服务当你完成了 retrofit 的配置之后，就可以开始创建服务请求了。retrofit 通过接口的方式来提供网络上的请求，下面通过简单的例子来看看如何创建服务。 12345public interface IMovieTop250 &#123; @GET("v2/movie/top250?") Observable&lt;JsonResult&lt;List&lt;Subject&gt;&gt;&gt; getMovie(@Query("start") int start, @Query("count") int count);&#125; 这里接上一篇《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》 中的json结果，使用的是豆瓣电影的API Top250 的API，Url 请求长这样：https://api.douban.com/v2/movie/top250?start=0;count=1 填写请求地址 我们这样来分解，把 https://api.douban.com/ 作为base_url ，剩下的 v2/movie/top250? 作为这个接口请求的url。前面放上 GET 关键字表示请求的方式。base_url 我们将在 serviceManager 中去处理，后面会提到。 特别提示：base_url 需要以斜杠 / 结尾，否则会报错 确定返回类型 写好了请求的地址，我们来写请求返回的参数类型 Observable&lt;JsonResult&lt;List&lt;Subject&gt;&gt;&gt; 表示从 API 返回一个 JsonResult 类型，并且这里使用了 rxjava ，所以是 Observable 而并不是 Call 。 填写请求参数（如果需要） 这里我们需要两个参数，采用 Query 关键字，键值对中键的名称分别为 start 和 count 写在括号中，后面写上对应的变量名。 关于请求的关键字如 GET POST 可以去 这里 查看 这里我们看到一个请求地址就对应着一个接口，当然你可以在一个接口中创建多个请求方法（一般用在同一类型的请求但是各个请求的参数有区别的情况）。这里举一个例子： 1234567891011public interface ISubmitService &#123; @POST("confirmOrder?") Observable&lt;SubmitEntity&gt; submitSaleOrder(@Query("id") int id, @Query("task_id") int taskId); @POST("confirmOrder?") Observable&lt;SubmitEntity&gt; submitRepairOrder(@Query("id") int id, @Query("task_id") int taskId, @Query("order_id") int orderId, @Query("order_type") String orderType);&#125; 这个请求接口中两个请求方法只是请求的参数不同而已。 完成了以上步骤就创建好了 接口形式的网络请求了。 三 配置你的 ServiceManager当你完成了请求接口的创建之后，我们会使用一个 serviceManager 去管理这些众多的接口请求。示例代码如下： 1234567891011121314151617181920212223public class ServiceManager &#123; private static ServiceManager instance = null; public synchronized static ServiceManager getInstance() &#123; return instance != null ? instance : new ServiceManager(); &#125; private OkHttpClient client = new OkHttpClient() .newBuilder() .addInterceptor(new HttpLoggingInterceptor() .setLevel(BuildConfig.DEBUG ? HttpLoggingInterceptor.Level.BODY : HttpLoggingInterceptor.Level.NONE)) .build(); private Retrofit retrofit = new Retrofit.Builder() .baseUrl(StrUtil.BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); private IMovieTop250 iMovieTop250 = retrofit.create(IMovieTop250.class); public IMovieTop250 getiMovieTop250() &#123; return iMovieTop250; &#125;&#125; 简单的说明一下： 首先创建了一个 serviceManager 的单例。然后配置好 OkHttpClient 以及 Retrofit ，相关的注释比较清晰看一下就能明白。 当我们创建好 Retrofit 以后，就可以创建接口服务了使用 retrofit.create(IMovieTop250.class) 创建你的服务。最后向引用类提供一个方法 getiMovieTop250() 来实现请求即可。 至此，所有的请求工作都完成了。下面我们看一下去使用这些服务。 四 使用服务首先看一下代码示例： 12345678910111213141516171819202122232425262728293031323334353637// get movie from apiprivate void getMovie(int start, int count) &#123; ServiceManager.getInstance() .getiMovieTop250() .getMovie(start, count) .flatMap(new Func1&lt;JsonResult&lt;List&lt;Subject&gt;&gt;, Observable&lt;Subject&gt;&gt;() &#123; @Override public Observable&lt;Subject&gt; call(JsonResult&lt;List&lt;Subject&gt;&gt; listJsonResult) &#123; return Observable.from(listJsonResult.getSubjects()); &#125; &#125;) .toList() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Subject&gt;&gt;() &#123; @Override public void onNext(List&lt;Subject&gt; subjects) &#123; if (subjects != null) &#123; myAdapter.setDataList(subjects); &#125; &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; if (e instanceof java.net.ConnectException) &#123; Toast.makeText(MainActivity.this, "当前网络不可用",Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;);&#125; 调用很简单直接通过 serviceManager 就能使用服务了 123ServiceManager.getInstance() .getiMovieTop250() .getMovie(start, count) 剩下的代码需要去看一下我的关于 Rxjava 介绍的文章 《 Retrofit + Rxjava 从入门到跑路（Rxjava介绍）》。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit + RxJava 从入门到跑路（Rxjava介绍）]]></title>
      <url>%2F2016%2F12%2F26%2FRetrofit-RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Rxjava%E4%BB%8B%E7%BB%8D%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本文较长建议在电脑上阅读(文中除 RxJava + Retrofit 结合运用部分，其余代码示例来自 扔物线 博客) 2016年也差不多要结束了，作为一个Android小白今年学到的东西回头来看发现还是太少了。给我印象最深的是 MVP设计模式、Retrofit以及RxJava。这篇文章就来讲一下Retrofit和RxJava。 网上有很多这两者相关的资料但是结合起来的文章比较少，本着我们学习的目的是为了真正在工作项目中使用，所以决定写下这篇文章，本人由于工作经验较少文中出现错误了希望大家指出纠正。 这里我要先分开讲两者然后再结合起来，只有分开弄清楚了才能在结合的时候运用自如。 ​RxJava首先强烈推荐 扔物线 大大的这篇文章 《给 Android 开发者的 RxJava 详解》 毫不夸张的说，如果真正吃透了这篇文章肯定是能够理解并使用RxJava了（这篇文章较长，系统的介绍了RxJava）。 本人也是看了许多RxJava的文章最终发现了这篇文章才对RxJava形成了一个相对清楚的认识和理解。这里我就用我自己的理解在来梳理一下RxJava。 为什么要用Rxjava，以及什么场景下使用 a library for composing asynchronous and event-based programs by using observable sequences.— from Rxjava github 通过使用可观察序列来组成异步和基于事件的程序的库。 异步 + 简洁 是Rxjava的关键词 。 在需要处理异步的场景下使用：Rxjava的本质还是为了处理异步这件事。 因为Rxjava处理逻辑的十分简洁 ，采用了链式的组织方式使得方便拼接来处理复杂的逻辑。 介绍观察者模式因为Rxjava在处理异步问题的时候采用的是 观察者模式。我们首先来熟悉一下观察者模式。其实对于Android日常开发中我们已经非常熟练的去使用了观察者模式了。我们都使用过Button，写过Button的点击事件。 名词解释（熟悉自行跳过直接看 代码实现 ） 所谓的 观察者模式 也可以称为 注册-订阅模式，就拿当下十分流行的直播来类比一下。比如我很喜欢B站的一位阿婆主（咦，好像暴露了什么）。她的每次直播我都想看，假设阿婆主直播的时间不是固定的，那我很有可能错过直播那我应该怎么做才能解决这个问题呢？ 两种方式： 阿婆主每次直播的时候自己主动通知我（我觉得只有可能我在阿婆主的粉丝群里或者就我一个观众 233才可能这样） 我在B站上关注了阿婆主。注意噢，这里的关注就是意味着订阅了，也就是说只要阿婆主有直播我就能收到通知。 至此我想你应该懂了什么叫 注册-订阅（观察者）模式了，就是说只要我订阅了某个事件源（阿婆主开直播），当事件发生时我就能收到通知。好，我们接下来用一张表来更加清晰的看看这个模式的各个部分组成。 观察者（事件处理者） 被观察者（搞事者） 订阅 我 阿婆主 关注阿婆主这个动作 现在的直播都是采用观察者模式的，好处就是在于无论阿婆主有多少粉丝只要你关注（订阅）了阿婆主，当阿婆主开直播了，这个事件消息能够发送给所有订阅了的粉丝。也就是不需要阿婆主每一个人去挨个通知了。 我们现在再回到开头的提到的Button的这个事情。我们换一种说法可以把观察者模式理解成为监听模式。关注阿婆主之后就好像放置了一个监听器一直在监听阿婆主是否开播这个事件。一旦阿婆主开播事件被触发监听器就启动，然后执行相应的处理（观看直播 or 给阿婆主刷刷礼物）。 所以看到这里写Android的小伙伴是不是觉得监听器有点熟悉，这个在Button上监听它被点击了的监听器不就是OnClickListener吗？当Button（被观察者 or 事件源）被点击之后，OnClickListener（观察者 or 事件处理者）就开始执行相应的操作，可能是跳转Activity也可能是弹出dialog等等。那这个监听器是在哪里订阅或者说关注了Button的一举一动的呢？当然就是在你经常写的 btn.setOnClickListener()的时候啦。在这个时候Button已经被OnClickListener所关注了。 Observer 观察者（事件处理者） Observable 被观察者（搞事者） Subscribe 订阅 我 阿婆主 关注阿婆主这个动作 OnClickListener 监听器 Button 按钮 setOnClickListener 绑定监听 好的，啰嗦了这么多我为什么要介绍这个观察者模式呢？ 是因为我们Rxjava就是要处理异步问题的，异步一般来说那个不在主线程中的任务会比较耗时，为了防止ANR就会用到观察者模式。观察者不用时时刻刻去查看是否需要更新View了（如果那样好累的说）只要我关注了我需要关注的事件源（比如Button的点击事件）就可以在发生了特定事件的时候获得消息然后再更新View。 代码实现. 0 如何引入Rxjava Example for Gradle: 12345// in your modules' build.gradle // Rxjava compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2' // RXandroid compile 'io.reactivex:rxandroid:1.0.1' 1 创建观察者（事件处理者）Observer观察者决定了当事件被触发了做出怎样的回应（在onNext 方法中处理）。 123456789101112131415Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; ​ 首先说明我们在实际的开发中一般创建观察者的时候使用的并不是Observer而是Subscriber。Observer正如其字面的意思就是观察者，是一个接口里面的接口方法就是上面的三个方法，onNext() onCompleted() onError() 。而在实际开发中使用到的Subscriber是什么呢？通过查看源码 public abstract class Subscriber implements Observer, Subscription ，原来Subscriber是一个抽象类它实现了 Observer 和 Sbuscription 这两个接口。 Observer — onNext() onCompleted() onError() subscription — unsubscribe() isUnsubscribed() 其实Subscriber的用法跟Observer用法基本一致，相比于Observer多了一些重写方法,从表格中可以看出多了unsubscribe() 和 isUnsubscribed() 这两个方法。 新增的这两个接口方法有着重要的意义，unsubscribe() 用于取消订阅。恩，既然我可以关注一个阿婆主当然也能够取消关注嘛。这个方法一般是在 onStop() 或者 onPause() 中去实现，取消订阅释放内存防止内存泄漏。阿婆主我取消对你关注了你不可能还死皮赖脸的缠着不放吧 233 。 下面是 subscribe的创建（其实基本都是一样的）。 123456789101112131415161718Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; 2 创建被观察者（搞事者）Observable Observable决定了发送什么事件以及何时发送时间即 what &amp; when。 12345678Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("Hello"); subscriber.onNext("World"); subscriber.onCompleted(); &#125;&#125;); 我们从上面的简单例子可以看到不管是观察者还是被观察者处理的数据类型都是基本的String类型。在真实的项目开发中，我们在使用Rxjava + Retrofit 的时候要处理的类型往往是通过服务器给定的，通常事先是不知道的。这就需要我们在类型的地方使用泛型来处理，这里只是简单的示例。 除了可以使用 create来创建一个被观察者还可以使用just 和 from， 而这些都被称作操作符，大家可以去这里 了解一下。 3 订阅Subscribe 只要在 Observable中订阅一下，将Observe与其连接起来就是完成订阅了。 举例说明一下： 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： 123456789101112131415161718192021222324int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, "Error!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 好，至此我们已经看到了整个观察者模式一个完整的流程了即创建 Observable 和 Observe 然后通过 Subscribe 连接两者即可。 真正的使用Rxjava在上面一节 介绍观察者模式中我们提出来完整的流程，我们也就基本的了解了Rxjava的工作流程，但是这不是Rxjava真正的使用方式！ 因为我们使用Rxjava的最初目的还是处理 异步问题。而目前为止所看到的所有代码都是在同一个线程中执行的，所以并不是Rxjava真正的使用方式。接下来，我们就要在不同的线程之间去使用Rxjava。 为了在不同的线程中去使用Rxjava这就表明我们需要线程切换。我在A线程做一件事情，然后切换到B线程去做另外一件事情。刚好Rxjava提供了调度器，它可以用来切换线程。在Rxjava中使用Schedulars — 调度器来切换线程。该调度器已经默认提供了一些线程可供我们使用。 方法名 描述 immediate() 在当前线程中执行(缺省模式) computation() 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 io() I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程 newThread() 总是创建新的线程，并在新的线程中执行 mainThread() Android中的主线程 一般在实际的项目中用到最多的就是 io newThread 以及 mainThread 这三个线程。在被观察者中 Observable提供了 两个方式分别是 subscribeOn() 和 observeOn() 来指定观察者和被观察者分别运行在哪个线程。 举例说明： 1234567891011ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;ApiResult&lt;Subject&gt;&gt;(context) &#123; @Override public void onNext(ApiResult&lt;Subject&gt; subjectApiResult) &#123; // do something &#125; &#125;); 从这个例子上我们可以看到 观察者是运行在新的线程上而 被观察者则是运行在主线程上。注意看在subscribeOn() 的前一句是获取电影的相关信息 getMovie()， 而获取这个信息需要的时间可能较长且不确定所以放在了另外一个新的线程中去执行你可以说实在后台线程执行。最后得到数据之后在再主线程中进行相应的处理。（这里已经是使用了Rxjava + Retrofit） Rxjava是如此的灵活如果你能看到这里非常感谢，以上的内容都是介绍和解释了Rxjava 是如何处理异步问题。还记得文章最开头提到的Rxjava的两个关键词吗？ 异步 + 简洁， 这一节就要介绍Rxjava为什么相比于其他处理异步问题的方式为什么简洁、灵活。 我们先来说说什么样的逻辑是容易被理解的。我个人认为直的逻辑，换句话说不需要考虑各种分支各种例外情况或者是多层关系的逻辑是容易被理解的（层级、依赖、分支较少的逻辑我认为就是直的逻辑）。好比路线，一条直路就能到达目的地当时给人的感觉是清晰、简单的。恰好，Rxjava就是这种链式的一条直的逻辑。依靠着众多 操作符 能够非常方便的实现拼积木的感觉（多了直接扔掉，少了直接加上就好不用考虑依赖、层级之间的关系）。 举例演示一下（注意这里Rxjava和Retrofit结合在使用） 1234567891011121314151617181920212223ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .flatMap(new Func1&lt;ApiResult&lt;Subject&gt;, Observable&lt;Subject&gt;&gt;() &#123; @Override public Observable&lt;Subject&gt; call(ApiResult&lt;Subject&gt; subjectApiResult) &#123; return Observable.from(subjectApiResult.getSubjects()); &#125; &#125;) .map(new Func1&lt;Subject, String&gt;() &#123; @Override public String call(Subject subject) &#123; return subject.getTitle(); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;String&gt;(context) &#123; @Override public void onNext(String s) &#123; apiResultTv.setText(s); &#125; &#125;); ok,对于刚刚接触Rxjava的人可能一下子会觉得真正使用Rxjava是这么的麻烦，看着代码好像很多逻辑反而不清晰呢。其实这只是由于新接触Rxjava被表面的代码书写格式所吓到了而已。下面来分析一下这一串代码，首先介绍一下背景： 我通过豆瓣电影API得到电影Top250 的相关信息，然后在手机上显示出来更新UI。 豆瓣电影API可以在 这里查看 ，此处代码使用的是 榜单 Top250 这个接口(json返回结果较复杂请耐心分析)。在chrome浏览器中下载 postman 然后输入 https://api.douban.com/v2/movie/top250?start=0&amp;count=10 查看json返回结果。 我们来分析代码，首先通过getMovie() 得到了API所返回的json结果。这里根据提供的json结果返回的格式是 Observable &lt; ApiResult&lt; Subject&gt;&gt; 是一个被观察者Observable （这里真实的场景就是我们通过网络就得到了被观察者而不是自己去创建），然后我们开始多次使用操作符来对这个最原始的 json返回结果进行剥离只留下我们需要的数据，比如这里我只需要榜单中电影的名字。 第一次我们使用了 flatmap 得到了subject ， 然后我们再使用了 map 得到了String 这个对应着电影的名字。此时被观察者所发出的事件中的数据由 Observable &lt; ApiResult&lt; Subject&gt;&gt; 变成了 String 。至此被观察者的事情就处理好了事件源返回了我们想要的那一部分的数据。接下来分别使用 subscribeOn 和 observeOn 来分别指定这些任务应该运行在哪个线程。显然我们指定了观察者的任务处理在 io 线程， 被观察者是运行在主线程中的。最后的最后，我们进行了关注 - 订阅 告诉观察者如果你收到了被观察者的事件通知应该做点什么（setText 更新了UI）。 好，如果你再结合上lambda 表达式的话，代码会看起来更清爽（但是个人不推荐）。 12345678910111213ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .flatMap(subjectApiResult -&gt; Observable.from(subjectApiResult.getSubjects())) .map(subject -&gt; subject.getTitle()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;String&gt;(context) &#123; @Override public void onNext(String s) &#123; apiResultTv.setText(s); &#125; &#125;); 总结一下：其实整个这一串代码就是链式下来的一个直的逻辑。 得到API返回结果 getMovie() 转化得到的结果为Subject flatMap() 转化得到的结果为String map() 指定线程 observeOn() subscribeOn() 订阅 subscribe() Rxjava 之所以说它灵活是因为在转化的过程中你想怎么转化都是可以的，它可以通过多种操作符来适应你的各种筛选要求。之后会用一篇文章介绍一下常用的一些操作符。 ​后记终于告一段落了，Rxjava 的基本介绍就这么多了，希望这边文章能给你们一点点帮助。本文中除了 Rxjava 与 Retrofit结合的代码是原创，剩下的示例代码来自 扔物线。还有如果想了解一下 lambda 表达式的同学可以去 这里学习 特别感谢 饭窝 扔物线 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[做一个Android计算器]]></title>
      <url>%2F2016%2F12%2F11%2F%E5%81%9A%E4%B8%80%E4%B8%AAAndroid%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%8C%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
      <content type="text"><![CDATA[知识点清单 TableLayout 相关知识 AnimationSet 相关知识（简单的动画效果实现） 可选 butterknife（声明 View 控件的另一种方式） 核心思路通过 后缀表达式 来计算输入的算式，是本程序逻辑的重点。 先来解释一下为什么做一个计算器会用到 后缀表达式 。我们人脑在处理算式的时候是按照 中缀表达式 的方式来处理的。比如：6 - 4 ，我们大脑处理这个算式的顺序很自然的就是6减去4最后得到结果。如果更复杂一些的算式如：6 - 4 x 3 ，我们第一反应是根据运算符的优先级别决定先运算4 x 3 然后再用6减去之前得到的结果。 综上所述，我们人脑在计算算式的时候其实是按照 中缀表达式 的顺序来计算的。但是如果我们程序采用这种方式来计算算式编写的逻辑会十分的麻烦，所以这里我们就提出来 后缀表达式 来方便程序逻辑的编写，同时也是方便计算机处理。所以在编写的逻辑中我们有着关键一步就是把 中缀表达式 转换成为 后缀表达式 。 好了，我们来从全局整理一下我们编写计算器的逻辑。 1 得到用户输入的算式（此算式为中缀表达式所表示）。 2 将此中缀表达式转化成后缀表达式。 3 计算转化得到的后缀表达式得出算式结果。 实现步骤项目地址 这里只讨论关键思路，详细的代码请查看项目地址中的代码。 获得用户输入的具体过程 按照中缀表达式（即从左到右的顺序把 String 存到栈中） 1 用 num 作为一个存放数字或者点号的临时变量。 2 判断当前要存入栈的字符是 运算符 还是 数字或者点号。 3 交替的存入 num 和 运算符。 ps：需要注意的一种情况是。用户输入进来的字符串的第一个字符是 运算符，若为此种情况应当在该字符串的首位添加一个0保证后续计算的正确性！（若没有添加0，在使用后缀表达式计算的时候会由于缺少一个运算数报错）。 举例：用户此时的输入是 -6-2 ， 按照后缀表达式的规则先把该式子写成后缀表达式为 6-2- ，然后按照后缀表达式的计算规则，当读到运算符（第一个减号）的时候，弹出前面入栈的两个元素进行计算，但此时在减号前面入栈的只有6这一个元素无法计算，因此报错。 把中缀表达式转变成后缀表达式（重点讨论） 1 建立两个栈， 一个是存放转化成为后缀表达式的栈 A，一个是存放运算符的栈 B。 2 首先根据上一步，我们已经保证了得到的输入字符串的首位肯定是一个数字。开始进行转化逻辑如下： ​ 从左向右依次读取字符串 ​ 2.1 如果是数字或者点号存入到 A ​ 2.2 如果是运算符，一 当 B 栈为空则直接放入 B； 二 B 栈不为空把该栈顶元素与当前得到的元算符进行优先级比较。如果运算符栈顶运算符的优先级大于当前运算符则把栈顶运算符存入到 A ，把当前运算符存入到 B 中；如果运算符栈顶元素的优先级小于当前元算符，则直接把当前运算符存入到 B 中。 ​ 2.3 检查 B 栈 ， 如果还有元素存在则都存入 A 中。 ​ 3 最终得到 A 栈中的结果就是用后缀表达式的方式所表示的字符串。 举例：中缀表达式为 6-5x4 1 把6放入栈 A 中。 2 把减号放入栈 B 中。 3 5放入栈 A 中。 4 乘号由于比 B 中的减号优先级高则直接放入栈 B 中。（此时是运算符栈顶元素减号优先级小于当前元素乘号的情况）。 5 把4放入栈中 此时两个栈的情况是： A ：654； B：-X ； 6 最后把 B 中的元素弹出依次放入 A 中，最终得到的后缀表达式为 654x- 举例：中缀表达式为6x5-4 1 存入6到 A 栈中。 2 把乘号放入运算符栈 B 3 5存入栈 A 中。 4 减号是当前元素由于元算符 B 栈顶元素是乘号优先级高于减号，所以弹出 B 栈的栈顶元素即乘号放入 A 中，然后把当前元素 减号 再放入 B 中。此时两个栈的情况为： A：65x ； B：- ； 5 把4放入 A 中。 6 把 B 中所有的元素（若有）放入 A 中，即把减号放入 A 中。最终得到的后缀表达式为 65X4- 计算后缀表达式 从左至右依次读取由后缀表达式表示的字符串 1 如果读到当前字符是数字或者点号则存入栈中。 2 如果读到运算符则把栈顶的两个元素弹出来然后用该运算符对其计算，所得到的结果再存入栈中。 以上就是整个计算器实现的关键思路了，详细的代码可以去项目查看。如果你有什么问题可以在项目中 讨论 中交流。 对了对了，最后如果你也喜爱二次元或者喜爱翻唱欢迎来加微博，在博客的左边。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
