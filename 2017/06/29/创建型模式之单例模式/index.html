<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  <title>
    
      创建型模式之单例模式 | Jngoogle
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
  <script src="/js/gitment.js"></script>
</head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Jngoogle</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>创建型模式之单例模式</h2>
  <p class="post-date">2017-06-29</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body">
  <article class="post-article">
    <section class="markdown-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>ps: 本文较长，请分段阅读</p>
</blockquote>
<p><img src="http://imglf1.nosdn.127.net/img/R3RmT3FSa2l4djRyQmgrU2R2VUpwN0Z2ME9OZUlEdnZGMkN4bFhwYVBDdlpveitaYXZUZ21BPT0.png?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2&amp;text=wqkg5ZOO5ZGm5LiN6ZSZ5ZOfIC8gamFtbWljbmljb29sZS5sb2Z0ZXIuY29t&amp;font=bXN5aA==&amp;gravity=southwest&amp;dissolve=30&amp;fontsize=240&amp;dx=8&amp;dy=10&amp;stripmeta=0" alt="设计模式结构图"></p>
<p>上图列举出来所有设计模式的结构图，这次就来看看单例模式。</p>
<p>在软件设计中，许多地方用到的实例是不需要创建多个实例，例如在 Windows 系统中有且仅有一个任务管理器（<em>它也确实不需要多个，并且如果有多个将出现很多问题</em>）。不管是实际情况的需要还是为了提高性能，当我们只需要一个实例的时候就可以使用单例模式来设计。</p>
<p>我们就从日常开发中使用最多的 单例模式 开始我们的设计模式学习。</p>
<p><br></p>
<h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><p>单例模式的定义是：<strong>确保某一个类只有一个实例，并自行实例化且向整个系统提供这个实例</strong>。</p>
<ul>
<li>只有一个实例</li>
<li>必须是自行实例化</li>
<li>提供全局访问的方法</li>
</ul>
<p><br></p>
<h3 id="如何实现单例模式"><a href="#如何实现单例模式" class="headerlink" title="如何实现单例模式"></a>如何实现单例模式</h3><h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>创建一个类假设是 SingleInstance，然后保证它的构造方法（<em>无参数</em>）的访问权限是 private ，避免外部类使用 new 创建多个实例（此时外部类无法使用 new 来创建该单例）。</p>
<h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>创建 SingleInstance中的成员变量假设是 sInstance（<em>类型是 SingleInstance</em>） ，使用 private 和 static 进行修饰即私有的静态变量，保证其是该 单例的唯一实例。</p>
<h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>在 SingleInstance类中创建一个 public 修饰的公共方法 getInstance ，提供给外部类调用该方法来引用这个单例。</p>
<p><br></p>
<h3 id="具体实现方式"><a href="#具体实现方式" class="headerlink" title="具体实现方式"></a>具体实现方式</h3><p>实现单例模式有几种不同的方法，下面逐一来看看这几种使用单例的方式。</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p><strong>方法特点：</strong> 直接在类中 new 出成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> sInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现方式由于直接 new 出了成员变量，所以在类被加载的时候同时就会创建该单例。在 getInstance 方法中就可以直接返回 sInstance 这个单例。</p>
<p><br></p>
<p><strong>需要注意的是创建该类的构造方法的时候要使用 private 修饰，保证外部类不可以使用 new 来创建多个实例。</strong></p>
<p><br></p>
<p>总结：</p>
<ul>
<li>当单例类构造方法比较简单，逻辑不复杂的时候可以采用（<em>但是并不推荐</em>），一般来说开发的过程中不要使用 饿汉式 来实现单例模式。 </li>
<li>如果类的构造方法复杂，可能会导致类加载很慢。</li>
<li>类加载的时候没有真正的调用，浪费内存资源。</li>
</ul>
<p><br></p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>为了解决 饿汉式 存在的问题，我们可以采用懒汉式的方式来实现单例模式。</p>
<p><strong>方法特点：</strong> 不直接在类中 new 出成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == sInstance) &#123;</div><div class="line">          sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> sInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法解决掉了之前 饿汉式 的性能问题，但是当处于多个线程的时候我们使用上述代码会出现一个严重的问题。嗯，聚个栗子：</p>
<blockquote>
<p>现在有两个线程分别为 A 线程、B 线程（<em>简称 A 和 B</em>）。 </p>
<p>当 A 执行上面的代码，第一次实例化的时候判断 sInstance 是否为 null，现在为 null 则在 A 中开始创建 SingleInstance 如果创建这个类需要很长的时间,在这个时候 B 线程也执行了上面的代码。B 线程中由于在 A 中的实例还在创建中没有完成，所以 B 中会判断 sInstance 为 null，然后也开始创建实例了。这就导致创建了两个实例，不符合单例模式的设计。</p>
</blockquote>
<p>要解决这个问题就是让 A 在执行上面代码的时候，B 线程不能执行直到 A 执行完成了。这样 B 再执行的时候 sInstance 就不是 null 了，自然也就不会再创建新的实例了。</p>
<p>使用线程锁就可以实现上述过程，所以我们修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == sInstance) &#123;</div><div class="line">          sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> sInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>synchronized</code>  是可以保证多线程、单一实例的方法。有了这个线程锁，很多线程都要执行上面代码的时候就必须要排队，一个一个的来。前面的线程没有使用完这个方法，后面来的线程是没有权限执行这个方法的。</p>
<p>ok，一般开发中大家可能都是使用的 懒汉式 这种实现方式。</p>
<p>但是有一个问题。如果多个线程都要执行这块代码，当第一个线程执行完了这块代码创建了实例。后面的线程才能执行代码去获取  <code>synchronized</code>  这个线程锁，注意获取它是一个耗时操作，但是此时实例已经创建了其实已经没有必要再去获取线程锁了。这里就造成了性能低下的问题。</p>
<p><br></p>
<p>总结：</p>
<ul>
<li>通过使用 <code>synchronized</code>   解决了多线程的问题但是此方式效率并不高，不推荐。</li>
</ul>
<p><br></p>
<h4 id="双重检查锁定方式-double-checked-locking"><a href="#双重检查锁定方式-double-checked-locking" class="headerlink" title="双重检查锁定方式   double-checked locking"></a>双重检查锁定方式   double-checked locking</h4><p>由于获取线程锁 <code>synchronized</code>    是一个耗时的操作，要解决 懒汉式 的问题出现了 双重检查锁定的方式。</p>
<p>该方法的思路也很简单，就是如果这个实例由前面的线程创建了的话，后面的线程在执行代码的时候先判断有没有这个实例，如果有了就不去获取线程锁直接返回已经创建好的实例；没有的话才会去创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingleInstance sInstance = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == sInstance) &#123;</div><div class="line">          <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == sInstance) &#123;</div><div class="line">                  sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> sInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中可以很清除的看到在  getInstance() 方法中，首先是判断 sInstance 是否为 null 。假设现在 A  和 B  两个线程，现在是 A  先执行上面的代码假设 A 已经创建好了实例，当 B  进入  getInstance() 方法后，先判断实例是否已经存在，此时是存在的所以不需要获取线程锁去创建实例直接返回实例即可。这样后面的线程不需要去获得线程锁大大提高了执行的效率。</p>
<p><br></p>
<p><strong>可能你会问为什么需要双重检查？</strong></p>
<p><br></p>
<p>在 Synchronized 中为什么还需要判断实例是否为空呢？我们举个比较特殊的</p>
<blockquote>
<p>同样我们有两个线程 A  和 B。现在我们假设这两个线程同时调用该方法（<em>现在是可以同时调用 getInstance() 方法的，由于没有 synchronized 线程锁</em>）。两个线程同时进入 getInstance() 方法同时在判断实例是否为空，好，此时都判断为空，这个时候假定 A 先获得了线程锁进入方法中去创建实例。当创建完成之后，A 释放，B 获得线程锁进入方法，如果这个时候不判断实例是否存在，则 B  就会创建实例，最终就有了两个实例了。</p>
</blockquote>
<p>ok, 解决了双重检查的问题最最重要的一点还没有提到就是 volatile  这个东西了。</p>
<p>注意在 SingleInstance 类中定义成员变量 sInstance 的时候是用了这个词的。那 volatile 是什么呢？这个具体等下下一篇来说，因为内容较多就不放在这一篇里了，不过你可以去参考一下 <a href="https://www.ibm.com/developerworks/java/library/j-dcl/index.html" target="_blank" rel="external">这里。</a></p>
<p><br></p>
<h4 id="IoDH-方式"><a href="#IoDH-方式" class="headerlink" title="IoDH 方式"></a>IoDH 方式</h4><p>饿汉式不能实现延迟加载，不管使用与否都将占用内存；懒汉式线程安全需要去控制线程锁比较麻烦。那么现在还有一种方式来同时有两种方式的优点并且去掉他们的缺陷！它被称为 Initialization Demand Holder（IoDH）方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceHolder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在类中创建了一个静态持有类  SingleInstanceHolder 。利用静态类在被加载的时候才会创建的特性，故当 SingleInstance类被加载的时候，如果此时没有加载 SingleInstanceHolder 则该类并不会被加载。这样就能保证在类没有被调用的时候不会占用内存。我们在公有方法中通过该类引用到单例实例。</p>
<p><br></p>
<p>总结：</p>
<ul>
<li>IoDH 方式综合了了饿汉式 和 懒汉式 两种方式的优点同时也避免了缺陷。</li>
</ul>
<p><br></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p> <a href="https://gof.quanke.name/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" target="_blank" rel="external">《设计模式 java 版》</a>- sunny</p>
<p><a href="https://www.ibm.com/developerworks/java/library/j-dcl/index.html" target="_blank" rel="external">Double-checked locking and the Singleton pattern</a></p>
<p><a href="http://droidyue.com/blog/2015/01/11/looking-into-singleton/" target="_blank" rel="external">单例这种设计模式</a> - 技术小黑屋</p>
</section>
    
      <div class="tags">
        <span>Tags:</span>
        
  <span class="tag-code">设计模式</span>

      </div>
    
    <div class="money-like">
      <div class="reward-btn">
        赏
        <span class="money-code">
          <span class="alipay-code">
            <div class="code-image"></div>
            <b>使用支付宝打赏</b>
          </span>
          <span class="wechat-code">
            <div class="code-image"></div>
            <b>使用微信打赏</b>
          </span>
        </span>
      </div>
      <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
    </div>
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <div id="comments"></div>
  </article>
</main>

<script>
  (function () {
    var url = 'https://jngoogle.github.io/2017/06/29/创建型模式之单例模式/';
    $('#article-banner').geopattern(url)
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://yanm1ng.cn/error-img.png') 
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "jngoogle";
    if (gitmentConfig != "undefined") {
      var gitment = new Gitment({
        owner: "jngoogle",
        repo: "jngoogle.github.io",
        oauth: {
          client_id: "e21a6cb42390c6228eea",
          client_secret: "b28851784902edf98f91d128edbed3b77ccacd24"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>
<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>