<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Retrofit + RxJava 从入门到跑路（Rxjava介绍）]]></title>
      <url>%2F2016%2F12%2F26%2FRetrofit-RxJava-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%EF%BC%88Rxjava%E4%BB%8B%E7%BB%8D%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本文较长建议在电脑上阅读(文中除 RxJava + Retrofit 结合运用部分，其余代码示例来自 扔物线 博客) 2016年也差不多要结束了，作为一个Android小白今年学到的东西回头来看发现还是太少了。给我印象最深的是 MVP设计模式、Retrofit以及RxJava。这篇文章就来讲一下Retrofit和RxJava。 网上有很多这两者相关的资料但是结合起来的文章比较少，本着我们学习的目的是为了真正在工作项目中使用，所以决定写下这篇文章，本人由于工作经验较少文中出现错误了希望大家指出纠正。 这里我要先分开讲两者然后再结合起来，只有分开弄清楚了才能在结合的时候运用自如。 ​RxJava首先强烈推荐 扔物线 大大的这篇文章 《给 Android 开发者的 RxJava 详解》 毫不夸张的说，如果真正吃透了这篇文章肯定是能够理解并使用RxJava了（这篇文章较长，系统的介绍了RxJava）。 本人也是看了许多RxJava的文章最终发现了这篇文章才对RxJava形成了一个相对清楚的认识和理解。这里我就用我自己的理解在来梳理一下RxJava。 为什么要用Rxjava，以及什么场景下使用 a library for composing asynchronous and event-based programs by using observable sequences.— from Rxjava github 通过使用可观察序列来组成异步和基于事件的程序的库。 异步 + 简洁 是Rxjava的关键词 。 在需要处理异步的场景下使用：Rxjava的本质还是为了处理异步这件事。 因为Rxjava处理逻辑的十分简洁 ，采用了链式的组织方式使得方便拼接来处理复杂的逻辑。 介绍观察者模式因为Rxjava在处理异步问题的时候采用的是 观察者模式。我们首先来熟悉一下观察者模式。其实对于Android日常开发中我们已经非常熟练的去使用了观察者模式了。我们都使用过Button，写过Button的点击事件。 名词解释（熟悉自行跳过直接看 代码实现 ） 所谓的 观察者模式 也可以称为 注册-订阅模式，就拿当下十分流行的直播来类比一下。比如我很喜欢B站的一位阿婆主（咦，好像暴露了什么）。她的每次直播我都想看，假设阿婆主直播的时间不是固定的，那我很有可能错过直播那我应该怎么做才能解决这个问题呢？ 两种方式： 阿婆主每次直播的时候自己主动通知我（我觉得只有可能我在阿婆主的粉丝群里或者就我一个观众 233才可能这样） 我在B站上关注了阿婆主。注意噢，这里的关注就是意味着订阅了，也就是说只要阿婆主有直播我就能收到通知。 至此我想你应该懂了什么叫 注册-订阅（观察者）模式了，就是说只要我订阅了某个事件源（阿婆主开直播），当事件发生时我就能收到通知。好，我们接下来用一张表来更加清晰的看看这个模式的各个部分组成。 观察者（事件处理者） 被观察者（搞事者） 订阅 我 阿婆主 关注阿婆主这个动作 现在的直播都是采用观察者模式的，好处就是在于无论阿婆主有多少粉丝只要你关注（订阅）了阿婆主，当阿婆主开直播了，这个事件消息能够发送给所有订阅了的粉丝。也就是不需要阿婆主每一个人去挨个通知了。 我们现在再回到开头的提到的Button的这个事情。我们换一种说法可以把观察者模式理解成为监听模式。关注阿婆主之后就好像放置了一个监听器一直在监听阿婆主是否开播这个事件。一旦阿婆主开播事件被触发监听器就启动，然后执行相应的处理（观看直播 or 给阿婆主刷刷礼物）。 所以看到这里写Android的小伙伴是不是觉得监听器有点熟悉，这个在Button上监听它被点击了的监听器不就是OnClickListener吗？当Button（被观察者 or 事件源）被点击之后，OnClickListener（观察者 or 事件处理者）就开始执行相应的操作，可能是跳转Activity也可能是弹出dialog等等。那这个监听器是在哪里订阅或者说关注了Button的一举一动的呢？当然就是在你经常写的 btn.setOnClickListener()的时候啦。在这个时候Button已经被OnClickListener所关注了。 Observer 观察者（事件处理者） Observable 被观察者（搞事者） Subscribe 订阅 我 阿婆主 关注阿婆主这个动作 OnClickListener 监听器 Button 按钮 setOnClickListener 绑定监听 好的，啰嗦了这么多我为什么要介绍这个观察者模式呢？ 是因为我们Rxjava就是要处理异步问题的，异步一般来说那个不在主线程中的任务会比较耗时，为了防止ANR就会用到观察者模式。观察者不用时时刻刻去查看是否需要更新View了（如果那样好累的说）只要我关注了我需要关注的事件源（比如Button的点击事件）就可以在发生了特定事件的时候获得消息然后再更新View。 代码实现. 1 创建观察者（事件处理者）Observer观察者决定了当事件被触发了做出怎样的回应（在onNext 方法中处理）。 123456789101112131415Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; ​ 首先说明我们在实际的开发中一般创建观察者的时候使用的并不是Observer而是Subscriber。Observer正如其字面的意思就是观察者，是一个接口里面的接口方法就是上面的三个方法，onNext() onCompleted() onError() 。而在实际开发中使用到的Subscriber是什么呢？通过查看源码 public abstract class Subscriber implements Observer, Subscription ，原来Subscriber是一个抽象类它实现了 Observer 和 Sbuscription 这两个接口。 Observer — onNext() onCompleted() onError() subscription — unsubscribe() isUnsubscribed() 其实Subscriber的用法跟Observer用法基本一致，相比于Observer多了一些重写方法,从表格中可以看出多了unsubscribe() 和 isUnsubscribed() 这两个方法。 新增的这两个接口方法有着重要的意义，unsubscribe() 用于取消订阅。恩，既然我可以关注一个阿婆主当然也能够取消关注嘛。这个方法一般是在 onStop() 或者 onPause() 中去实现，取消订阅释放内存防止内存泄漏。阿婆主我取消对你关注了你不可能还死皮赖脸的缠着不放吧 233 。 下面是 subscribe的创建（其实基本都是一样的）。 123456789101112131415161718Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; 2 创建被观察者（搞事者）Observable Observable决定了发送什么事件以及何时发送时间即 what &amp; when。 12345678Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("Hello"); subscriber.onNext("World"); subscriber.onCompleted(); &#125;&#125;); 我们从上面的简单例子可以看到不管是观察者还是被观察者处理的数据类型都是基本的String类型。在真实的项目开发中，我们在使用Rxjava + Retrofit 的时候要处理的类型往往是通过服务器给定的，通常事先是不知道的。这就需要我们在类型的地方使用泛型来处理，这里只是简单的示例。 除了可以使用 create来创建一个被观察者还可以使用just 和 from， 而这些都被称作操作符，大家可以去这里 了解一下。 3 订阅Subscribe 只要在 Observable中订阅一下，将Observe与其连接起来就是完成订阅了。 举例说明一下： 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： 123456789101112131415161718192021222324int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, "Error!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 好，至此我们已经看到了整个观察者模式一个完整的流程了即创建 Observable 和 Observe 然后通过 Subscribe 连接两者即可。 真正的使用Rxjava在上面一节 介绍观察者模式中我们提出来完整的流程，我们也就基本的了解了Rxjava的工作流程，但是这不是Rxjava真正的使用方式！ 因为我们使用Rxjava的最初目的还是处理 异步问题。而目前为止所看到的所有代码都是在同一个线程中执行的，所以并不是Rxjava真正的使用方式。接下来，我们就要在不同的线程之间去使用Rxjava。 为了在不同的线程中去使用Rxjava这就表明我们需要线程切换。我在A线程做一件事情，然后切换到B线程去做另外一件事情。刚好Rxjava提供了调度器，它可以用来切换线程。在Rxjava中使用Schedulars — 调度器来切换线程。该调度器已经默认提供了一些线程可供我们使用。 方法名 描述 immediate() 在当前线程中执行(缺省模式) computation() 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 io() I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程 newThread() 总是创建新的线程，并在新的线程中执行 mainThread() Android中的主线程 一般在实际的项目中用到最多的就是 io newThread 以及 mainThread 这三个线程。在被观察者中 Observable提供了 两个方式分别是 subscribeOn() 和 observeOn() 来指定观察者和被观察者分别运行在哪个线程。 举例说明： 1234567891011ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;ApiResult&lt;Subject&gt;&gt;(context) &#123; @Override public void onNext(ApiResult&lt;Subject&gt; subjectApiResult) &#123; // do something &#125; &#125;); 从这个例子上我们可以看到 观察者是运行在新的线程上而 被观察者则是运行在主线程上。注意看在subscribeOn() 的前一句是获取电影的相关信息 getMovie()， 而获取这个信息需要的时间可能较长且不确定所以放在了另外一个新的线程中去执行你可以说实在后台线程执行。最后得到数据之后在再主线程中进行相应的处理。（这里已经是使用了Rxjava + Retrofit） Rxjava是如此的灵活如果你能看到这里非常感谢，以上的内容都是介绍和解释了Rxjava 是如何处理异步问题。还记得文章最开头提到的Rxjava的两个关键词吗？ 异步 + 简洁， 这一节就要介绍Rxjava为什么相比于其他处理异步问题的方式为什么简洁、灵活。 我们先来说说什么样的逻辑是容易被理解的。我个人认为直的逻辑，换句话说不需要考虑各种分支各种例外情况或者是多层关系的逻辑是容易被理解的（层级、依赖、分支较少的逻辑我认为就是直的逻辑）。好比路线，一条直路就能到达目的地当时给人的感觉是清晰、简单的。恰好，Rxjava就是这种链式的一条直的逻辑。依靠着众多 操作符 能够非常方便的实现拼积木的感觉（多了直接扔掉，少了直接加上就好不用考虑依赖、层级之间的关系）。 举例演示一下（注意这里Rxjava和Retrofit结合在使用） 1234567891011121314151617181920212223ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .flatMap(new Func1&lt;ApiResult&lt;Subject&gt;, Observable&lt;Subject&gt;&gt;() &#123; @Override public Observable&lt;Subject&gt; call(ApiResult&lt;Subject&gt; subjectApiResult) &#123; return Observable.from(subjectApiResult.getSubjects()); &#125; &#125;) .map(new Func1&lt;Subject, String&gt;() &#123; @Override public String call(Subject subject) &#123; return subject.getTitle(); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;String&gt;(context) &#123; @Override public void onNext(String s) &#123; apiResultTv.setText(s); &#125; &#125;); ok,对于刚刚接触Rxjava的人可能一下子会觉得真正使用Rxjava是这么的麻烦，看着代码好像很多逻辑反而不清晰呢。其实这只是由于新接触Rxjava被表面的代码书写格式所吓到了而已。下面来分析一下这一串代码，首先介绍一下背景： 我通过豆瓣电影API得到电影Top250 的相关信息，然后在手机上显示出来更新UI。 豆瓣电影API可以在 这里查看 ，此处代码使用的是 榜单 Top250 这个接口(json返回结果较复杂请耐心分析)。在chrome浏览器中下载 postman 然后输入 https://api.douban.com/v2/movie/top250?start=0&amp;count=10 查看json返回结果。 我们来分析代码，首先通过getMovie() 得到了API所返回的json结果。这里根据提供的json结果返回的格式是 Observable &lt; ApiResult&lt; Subject&gt;&gt; 是一个被观察者Observable （这里真实的场景就是我们通过网络就得到了被观察者而不是自己去创建），然后我们开始多次使用操作符来对这个最原始的 json返回结果进行剥离只留下我们需要的数据，比如这里我只需要榜单中电影的名字。 第一次我们使用了 flatmap 得到了subject ， 然后我们再使用了 map 得到了String 这个对应着电影的名字。此时被观察者所发出的事件中的数据由 Observable &lt; ApiResult&lt; Subject&gt;&gt; 变成了 String 。至此被观察者的事情就处理好了事件源返回了我们想要的那一部分的数据。接下来分别使用 subscribeOn 和 observeOn 来分别指定这些任务应该运行在哪个线程。显然我们指定了观察者的任务处理在 io 线程， 被观察者是运行在主线程中的。最后的最后，我们进行了关注 - 订阅 告诉观察者如果你收到了被观察者的事件通知应该做点什么（setText 更新了UI）。 好，如果你再结合上lambda 表达式的话，代码会看起来更清爽（但是个人不推荐）。 12345678910111213ServiceManager.getInstance() .getMovieService() .getMovie(0, 10) .flatMap(subjectApiResult -&gt; Observable.from(subjectApiResult.getSubjects())) .map(subject -&gt; subject.getTitle()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new MySubscriber&lt;String&gt;(context) &#123; @Override public void onNext(String s) &#123; apiResultTv.setText(s); &#125; &#125;); 总结一下：其实整个这一串代码就是链式下来的一个直的逻辑。 得到API返回结果 getMovie() 转化得到的结果为Subject flatMap() 转化得到的结果为String map() 指定线程 observeOn() subscribeOn() 订阅 subscribe() Rxjava 之所以说它灵活是因为在转化的过程中你想怎么转化都是可以的，它可以通过多种操作符来适应你的各种筛选要求。之后会用一篇文章介绍一下常用的一些操作符。 ​后记终于告一段落了，Rxjava 的基本介绍就这么多了，希望这边文章能给你们一点点帮助。本文中除了 Rxjava 与 Retrofit结合的代码是原创，剩下的示例代码来自 扔物线。还有如果想了解一下 lambda 表达式的同学可以去 这里学习 特别感谢 饭窝 扔物线 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[做一个Android计算器]]></title>
      <url>%2F2016%2F12%2F11%2F%E5%81%9A%E4%B8%80%E4%B8%AAAndroid%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%8C%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
      <content type="text"><![CDATA[知识点清单 TableLayout 相关知识 AnimationSet 相关知识（简单的动画效果实现） 可选 butterknife（声明 View 控件的另一种方式） 核心思路通过 后缀表达式 来计算输入的算式，是本程序逻辑的重点。 先来解释一下为什么做一个计算器会用到 后缀表达式 。我们人脑在处理算式的时候是按照 中缀表达式 的方式来处理的。比如：6 - 4 ，我们大脑处理这个算式的顺序很自然的就是6减去4最后得到结果。如果更复杂一些的算式如：6 - 4 x 3 ，我们第一反应是根据运算符的优先级别决定先运算4 x 3 然后再用6减去之前得到的结果。 综上所述，我们人脑在计算算式的时候其实是按照 中缀表达式 的顺序来计算的。但是如果我们程序采用这种方式来计算算式编写的逻辑会十分的麻烦，所以这里我们就提出来 后缀表达式 来方便程序逻辑的编写，同时也是方便计算机处理。所以在编写的逻辑中我们有着关键一步就是把 中缀表达式 转换成为 后缀表达式 。 好了，我们来从全局整理一下我们编写计算器的逻辑。 1 得到用户输入的算式（此算式为中缀表达式所表示）。 2 将此中缀表达式转化成后缀表达式。 3 计算转化得到的后缀表达式得出算式结果。 实现步骤项目地址 这里只讨论关键思路，详细的代码请查看项目地址中的代码。 获得用户输入的具体过程 按照中缀表达式（即从左到右的顺序把 String 存到栈中） 1 用 num 作为一个存放数字或者点号的临时变量。 2 判断当前要存入栈的字符是 运算符 还是 数字或者点号。 3 交替的存入 num 和 运算符。 ps：需要注意的一种情况是。用户输入进来的字符串的第一个字符是 运算符，若为此种情况应当在该字符串的首位添加一个0保证后续计算的正确性！（若没有添加0，在使用后缀表达式计算的时候会由于缺少一个运算数报错）。 举例：用户此时的输入是 -6-2 ， 按照后缀表达式的规则先把该式子写成后缀表达式为 6-2- ，然后按照后缀表达式的计算规则，当读到运算符（第一个减号）的时候，弹出前面入栈的两个元素进行计算，但此时在减号前面入栈的只有6这一个元素无法计算，因此报错。 把中缀表达式转变成后缀表达式（重点讨论） 1 建立两个栈， 一个是存放转化成为后缀表达式的栈 A，一个是存放运算符的栈 B。 2 首先根据上一步，我们已经保证了得到的输入字符串的首位肯定是一个数字。开始进行转化逻辑如下： ​ 从左向右依次读取字符串 ​ 2.1 如果是数字或者点号存入到 A ​ 2.2 如果是运算符，一 当 B 栈为空则直接放入 B； 二 B 栈不为空把该栈顶元素与当前得到的元算符进行优先级比较。如果运算符栈顶运算符的优先级大于当前运算符则把栈顶运算符存入到 A ，把当前运算符存入到 B 中；如果运算符栈顶元素的优先级小于当前元算符，则直接把当前运算符存入到 B 中。 ​ 2.3 检查 B 栈 ， 如果还有元素存在则都存入 A 中。 ​ 3 最终得到 A 栈中的结果就是用后缀表达式的方式所表示的字符串。 举例：中缀表达式为 6-5x4 1 把6放入栈 A 中。 2 把减号放入栈 B 中。 3 5放入栈 A 中。 4 乘号由于比 B 中的减号优先级高则直接放入栈 B 中。（此时是运算符栈顶元素减号优先级小于当前元素乘号的情况）。 5 把4放入栈中 此时两个栈的情况是： A ：654； B：-X ； 6 最后把 B 中的元素弹出依次放入 A 中，最终得到的后缀表达式为 654x- 举例：中缀表达式为6x5-4 1 存入6到 A 栈中。 2 把乘号放入运算符栈 B 3 5存入栈 A 中。 4 减号是当前元素由于元算符 B 栈顶元素是乘号优先级高于减号，所以弹出 B 栈的栈顶元素即乘号放入 A 中，然后把当前元素 减号 再放入 B 中。此时两个栈的情况为： A：65x ； B：- ； 5 把4放入 A 中。 6 把 B 中所有的元素（若有）放入 A 中，即把减号放入 A 中。最终得到的后缀表达式为 65X4- 计算后缀表达式 从左至右依次读取由后缀表达式表示的字符串 1 如果读到当前字符是数字或者点号则存入栈中。 2 如果读到运算符则把栈顶的两个元素弹出来然后用该运算符对其计算，所得到的结果再存入栈中。 以上就是整个计算器实现的关键思路了，详细的代码可以去项目查看。如果你有什么问题可以在项目中 讨论 中交流。 对了对了，最后如果你也喜爱二次元或者喜爱翻唱欢迎来加微博，在博客的左边。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
